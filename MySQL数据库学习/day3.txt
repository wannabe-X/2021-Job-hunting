MySQL day03课堂笔记

1.快速创建表？
	mysql> show tables;
	+-----------------------+
	| Tables_in_bjpowernode |
	+-----------------------+
	| dept                  |
	| emp                   |
	| salgrade              |
	| t_student             |
	| t_user                |
	+-----------------------+
	5 rows in set (0.00 sec)
	
	// 将查询的结果复制一份
	mysql> create table emp2 as (select * from emp);
	Query OK, 14 rows affected, 2 warnings (0.02 sec)
	Records: 14  Duplicates: 0  Warnings: 2

	mysql> show tables;
	+-----------------------+
	| Tables_in_bjpowernode |
	+-----------------------+
	| dept                  |
	| emp                   |
	| emp2                  |
	| salgrade              |
	| t_student             |
	| t_user                |
	+-----------------------+
	6 rows in set (0.00 sec)
	
	原理：
		将一个查询结果当做一张表新建
		可以完成表的快速复制
		表创建出来，同时表中的数据也存在了
	
	mysql> create table mytable as (select empno,ename from emp where job = 'MANAGER');
	Query OK, 3 rows affected (0.02 sec)
	Records: 3  Duplicates: 0  Warnings: 0

	mysql> select * from mytable;
	+-------+-------+
	| empno | ename |
	+-------+-------+
	|  7566 | JONES |
	|  7698 | BLAKE |
	|  7782 | CLARK |
	+-------+-------+
	3 rows in set (0.00 sec)

2.将查询结果插入到一张表当中？insert相关的
	// 如果存在，删除一张表
	mysql> drop table if exists dept_cpy;
	Query OK, 0 rows affected, 1 warning (0.01 sec)

	// 创建一张表。将查询结果当作一张表新建
	mysql> create table dept_cpy as select * from dept;
	Query OK, 4 rows affected (0.03 sec)
	Records: 4  Duplicates: 0  Warnings: 0

	// 显示新建的表
	mysql> show tables;
	+-----------------------+
	| Tables_in_bjpowernode |
	+-----------------------+
	| dept                  |
	| dept_cpy              |
	| emp                   |
	| emp2                  |
	| mytable               |
	| salgrade              |
	| t_student             |
	| t_user                |
	+-----------------------+
	8 rows in set (0.00 sec)

	// 查看新建表的内容
	mysql> select * from dept_cpy;
	+--------+------------+----------+
	| DEPTNO | DNAME      | LOC      |
	+--------+------------+----------+
	|     10 | ACCOUNTING | NEW YORK |
	|     20 | RESEARCH   | DALLAS   |
	|     30 | SALES      | CHICAGO  |
	|     40 | OPERATIONS | BOSTON   |
	+--------+------------+----------+
	4 rows in set (0.00 sec)
	
	// 将查询的结果插入到新建表中，追加。该方法很少用
	mysql> insert into dept_cpy select * from dept;
	Query OK, 4 rows affected (0.00 sec)
	Records: 4  Duplicates: 0  Warnings: 0

	mysql> select * from dept_cpy;
	+--------+------------+----------+
	| DEPTNO | DNAME      | LOC      |
	+--------+------------+----------+
	|     10 | ACCOUNTING | NEW YORK |
	|     20 | RESEARCH   | DALLAS   |
	|     30 | SALES      | CHICAGO  |
	|     40 | OPERATIONS | BOSTON   |
	|     10 | ACCOUNTING | NEW YORK |
	|     20 | RESEARCH   | DALLAS   |
	|     30 | SALES      | CHICAGO  |
	|     40 | OPERATIONS | BOSTON   |
	+--------+------------+----------+
	8 rows in set (0.00 sec)

3.快速删除表中的数据？
	// 删除dept_cpy表中的数据 
	mysql> delete from dept_cpy; //这种删除数据的方式比较慢
	Query OK, 12 rows affected (0.01 sec)	
	
	delete语句删除数据的原理：
		表中的数据被删除，但这个数据在磁盘上的真实存储空间不会被释放
		这种删除的缺点：删除效率比较低
		这种删除的优点：支持回滚，后悔了可以在使用回滚恢复数据。rollback命令
	
	delete 案例：
		mysql> select * from dept_cpy;
		Empty set (0.00 sec)
		
		// 追加数据
		mysql> insert into dept_cpy select * from dept;
		Query OK, 4 rows affected (0.01 sec)
		Records: 4  Duplicates: 0  Warnings: 0
		
		// 查看数据
		mysql> select * from dept_cpy;
		+--------+------------+----------+
		| DEPTNO | DNAME      | LOC      |
		+--------+------------+----------+
		|     10 | ACCOUNTING | NEW YORK |
		|     20 | RESEARCH   | DALLAS   |
		|     30 | SALES      | CHICAGO  |
		|     40 | OPERATIONS | BOSTON   |
		+--------+------------+----------+
		4 rows in set (0.00 sec)

		mysql> start transaction;
		Query OK, 0 rows affected (0.00 sec)
		
		// 删除数据
		mysql> delete from dept_cpy;
		Query OK, 4 rows affected (0.00 sec)

		// 查看数据，为空
		mysql> select * from dept_cpy;
		Empty set (0.00 sec)

		// 回滚
		mysql> rollback;
		Query OK, 0 rows affected (0.00 sec)
		
		// 数据恢复
		mysql> select * from dept_cpy;
		+--------+------------+----------+
		| DEPTNO | DNAME      | LOC      |
		+--------+------------+----------+
		|     10 | ACCOUNTING | NEW YORK |
		|     20 | RESEARCH   | DALLAS   |
		|     30 | SALES      | CHICAGO  |
		|     40 | OPERATIONS | BOSTON   |
		+--------+------------+----------+
		4 rows in set (0.00 sec)
	
	truncate删除数据的原理：
		这种删除效率比较高，表被一次阶段，物理删除
		这种删除的缺点：不支持回滚
		这种删除的优点：删除效率比较高
	
	truncate案例：
		// 查询数据
		mysql> select * from dept_cpy;
		+--------+------------+----------+
		| DEPTNO | DNAME      | LOC      |
		+--------+------------+----------+
		|     10 | ACCOUNTING | NEW YORK |
		|     20 | RESEARCH   | DALLAS   |
		|     30 | SALES      | CHICAGO  |
		|     40 | OPERATIONS | BOSTON   |
		+--------+------------+----------+
		4 rows in set (0.00 sec)
		
		// 删除表中数据，清空表
		mysql> truncate table dept_cpy;
		Query OK, 0 rows affected (0.03 sec)
	
		// 回滚
		mysql> rollback;
		Query OK, 0 rows affected (0.00 sec)
		
		// 回滚之后无法表中恢复数据
		mysql> select * from dept_cpy;
		Empty set (0.00 sec)
		
	用法：truncate table tept_cpy;(这种操作属于DDL操作)
	
	大表非常大，上一条记录？
		删除的时候，使用delete，也许需要执行1个小时才能删除完，效率较低
		可以选择使用truncate删除表中数据，只需要不到1秒钟就可以全部删完，效率较高。
		但是使用truncate之前，必须仔细询问客户是否真要删除，并警告删除之后无法恢复。
	
	删除表操作？
		drop table if exists 表名;

4.对表结构的增删改
	什么是对表结构的修改？
		添加一个字段，删除一个字段，或者修改一个字段
	
	对表结构的修改，需要使用：alter（属于DDL语句）
	
	DDL语句包括：create drop alter
		
	第一：在实际开发中，需求确定，表一旦设计好，很少进行表结构的修改
		因为开发进行中，修改表结构，成本比较高
		修改表的结构，对应的程序代码就需要进行大量的修改，成本比较高
		这个责任应该由设计人员承担
	
	第二：由于修改表结构的操作很少。如果需要修改表的结构，可以使用工具。例如navicat

5.约束
	1.什么是约束？
		约束的英文单词：constraint
		在创建表的时候，可以表中的字段加上一些约束，来保证这个表中的数据完整性、有效性。
	2.约束包括哪些？
		非空约束：not null
		唯一性约束：unique
		主键约束：primary key (简称PK)
		外键约束：foreign key (简称FK)
		检查约束：check (MySQL不支持，Oracle支持)
		
		重点学习4个约束：
			not null
			unique
			primary key
			foreign key
	3.非空约束：not null
		非空约束not null约束的字段不能为null
		
		drop table if exists t_vip;
		create table t_vip(
			id int,
			name varchar(255) not null
		);
		
		insert into t_vip(id,name) values(1,'zhangsan');
		insert into t_vip(id,name) values(2,'lisi');
		insert into t_vip(id) values(3);
	
		xx.sql这种文件被称为sql脚本文件。
		sql脚本文件中编写了大量的sql语句。
		执行sql脚本文件的时候，可以使用sql脚本文件。
		在MySQL当中是如何执行sql脚本的呢？
			source sql脚本的绝对路径
		
		执行sql脚本文件，数据库数据就有了
		
		// 因为name不能为空，所以只给id添加了数据而没有给name添加数据就会报错
		mysql> insert into t_vip(id) values(3);
		ERROR 1364 (HY000): Field 'name' doesn't have a default value
	
	4.唯一性约束：unique
		唯一性约束 unique约束的字段不能重复，但是可以为null
		
		drop table if exists t_vip;
		create table t_vip(
			id int,
			name varchar(255) unique,
			email varchar(255)
		);
		
		insert into t_vip(id,name,email) values
		(1,'zhangsan','zhangsan@123.com'),
		(2,'lisi','lisi@123.com'),
		(3,'wangwu','wangwu@123.com');
		
		select * from t_vip;
		
		mysql> select * from t_vip;
		+------+----------+------------------+
		| id   | name     | email            |
		+------+----------+------------------+
		|    1 | zhangsan | zhangsan@123.com |
		|    2 | lisi     | lisi@123.com     |
		|    3 | wangwu   | wangwu@123.com   |
		+------+----------+------------------+
		3 rows in set (0.00 sec)
		
		// 再插入name为'zhangsan'的信息，报错：'zhangsan'重复了
		mysql> insert into t_vip values(4,'zhangsan','zhangsan1@qq.com');
		ERROR 1062 (23000): Duplicate entry 'zhangsan' for key 't_vip.name'
		
		// 在unique约束下的字段中，null是可以重复的
		mysql> insert into t_vip values(5,null,'null1@qq.com');
		Query OK, 1 row affected (0.01 sec)

		mysql> insert into t_vip values(6,null,'null2@qq.com');
		Query OK, 1 row affected (0.01 sec)

		mysql> select * from t_vip;
		+------+----------+------------------+
		| id   | name     | email            |
		+------+----------+------------------+
		|    1 | zhangsan | zhangsan@123.com |
		|    2 | lisi     | lisi@123.com     |
		|    3 | wangwu   | wangwu@123.com   |
		|    5 | NULL     | null1@qq.com     |
		|    6 | NULL     | null2@qq.com     |
		+------+----------+------------------+
		5 rows in set (0.00 sec)
		
		// null可以重复
		mysql> insert into t_vip(id) values(5),(6);
		Query OK, 2 rows affected (0.01 sec)
		Records: 2  Duplicates: 0  Warnings: 0

		mysql> select * from t_vip;
		+------+----------+------------------+
		| id   | name     | email            |
		+------+----------+------------------+
		|    1 | zhangsan | zhangsan@123.com |
		|    2 | lisi     | lisi@123.com     |
		|    3 | wangwu   | wangwu@123.com   |
		|    5 | NULL     | NULL             |
		|    6 | NULL     | NULL             |
		+------+----------+------------------+
		5 rows in set (0.00 sec)
		
		name字段虽然被唯一性unique约束，但是可以为null。
		
		新需求：name和email联合起来使用唯一性约束。也就是多个字段的唯一性约束
			drop table if exists t_vip;
			create table t_vip(
				id int,
				name varchar(255) unique, // 约束添加在列的后面，称为列级约束
				email varchar(255) unique
			);
			这张表这样创建是不符合新需求的
			这样创建表示name具有唯一性，email具有唯一性，各自具有唯一性
			
			以下这样的数据是符合新需求的。
			但如果采用以上方式创建表，则会创建失败。
			因为'zhangsan'和'zhangsan'重复了。
			insert into t_vip values(1,'zhangsan','zhangsan@qq.com');
			insert into t_vip values(2,'zhangsan','zhangsan@sina.com');
			
			正确的创建方式为：
			drop table if exists t_vip;
			create table t_vip(
				id int,
				name varchar(255),
				email varchar(255),
				unique(name,email) // 约束没有添加在列的后面，称为表级约束
			);
			
			insert into t_vip values(1,'zhangsan','zhangsan@qq.com');
			insert into t_vip values(2,'zhangsan','zhangsan@sina.com');
			
			执行结果：
			mysql> drop table if exists t_vip;
			Query OK, 0 rows affected, 1 warning (0.00 sec)

			mysql> create table t_vip(
				-> id int,
				-> name varchar(255),
				-> email varchar(255),
				-> unique(name,email)
				-> );
			Query OK, 0 rows affected (0.02 sec)

			mysql>
			mysql> insert into t_vip values(1,'zhangsan','zhangsan@qq.com');
			Query OK, 1 row affected (0.00 sec)

			mysql> insert into t_vip values(2,'zhangsan','zhangsan@sina.com');
			Query OK, 1 row affected (0.00 sec)

			mysql> select * from t_vip;
			+------+----------+-------------------+
			| id   | name     | email             |
			+------+----------+-------------------+
			|    1 | zhangsan | zhangsan@qq.com   |
			|    2 | zhangsan | zhangsan@sina.com |
			+------+----------+-------------------+
			2 rows in set (0.00 sec)
			
			mysql> insert into t_vip values(1,'zhangsan','zhangsan@qq.com');
			ERROR 1062 (23000): Duplicate entry 'zhangsan-zhangsan@qq.com' for key 't_vip.name'
		
		什么时候使用表级约束？
			需要给多个字段联合起来添加某一个约束时，要使用表级约束
		
		not null只有列级约束，没有表级约束
		
		unique和not null 可以联合使用吗？
			drop table if exists t_vip;
			create table t_vip(
					id int,
					name varchar(255) unique not null
			);
			
			// unique和not null 可以联合使用
			// 在MySQL中，字段被unique和not null联合约束，该字段自动变成主键
			// 注意:Oracle中不一样
			mysql> drop table if exists t_vip;
			Query OK, 0 rows affected (0.02 sec)

			mysql> create table t_vip(
				-> id int,
				-> name varchar(255) unique not null
				-> );
			Query OK, 0 rows affected (0.03 sec)

			mysql> desc t_vip;
			+-------+--------------+------+-----+---------+-------+
			| Field | Type         | Null | Key | Default | Extra |
			+-------+--------------+------+-----+---------+-------+
			| id    | int          | YES  |     | NULL    |       |
			| name  | varchar(255) | NO   | PRI | NULL    |       |
			+-------+--------------+------+-----+---------+-------+
			2 rows in set (0.01 sec)
			
			mysql> insert into t_vip(id,name) values(1,'zhangsan');
			Query OK, 1 row affected (0.02 sec)
			
			mysql> select * from t_vip;
			+------+----------+
			| id   | name     |
			+------+----------+
			|    1 | zhangsan |
			+------+----------+
			1 row in set (0.00 sec)
			
			// 再次插入name为zhangsan记录，会受到unique约束而报错
			mysql> insert into t_vip(id,name) values(1,'zhangsan');
			ERROR 1062 (23000): Duplicate entry 'zhangsan' for key 't_vip.name'
			
			// 插入记录，name为null，会受到not null约束而报错
			mysql> insert into t_vip(id) values(2);
			ERROR 1364 (HY000): Field 'name' doesn't have a default value
	5.主键约束：primary key(简称PK)
		主键约束的相关术语：
			主键约束：就是一种约束
			主键字段：该字段上添加了主键字段，这样的字段叫做：主键字段
			主键值：主键字段中的每一个值都叫做：主键值
		
		什么是主键？作用是什么？（非常重要）
			主键值是每一行记录的唯一标识
			主键值是每一行记录的身份证号
		
		任何一张表都应该有主键，没有主键，表无效。
		
		主键的特征：not null + unique (主键值不能为null，同时也不能出现重复)
		类似于身份证号，中国人民的身份证号不能为null，不能出现重复。
		
		怎么给一张表添加主键约束？
		drop table if exists t_vip;
		// 一个字段做主键，叫做：单一主键
		create table t_vip(
			id int primary key, //列级主键
			name varchar(255)
		);
		
		insert into t_vip(id,name) values(1,'zhangsan');
		insert into t_vip(id,name) values(2,'lisi');
		insert into t_vip(id,name) values(2,'wangwu');
		
		// 创建t_vip表
		mysql> drop table if exists t_vip;
		Query OK, 0 rows affected (0.01 sec)

		// 设定id为主键
		mysql> create table t_vip(
			-> id int primary key,
			-> name varchar(255)
			-> );
		Query OK, 0 rows affected (0.02 sec)

		// 插入记录
		mysql> insert into t_vip(id,name) values(1,'zhangsan');
		Query OK, 1 row affected (0.00 sec)

		mysql> insert into t_vip(id,name) values(2,'lisi');
		Query OK, 1 row affected (0.01 sec)
		
		// 插入记录，但是id出现重复，会受到主键（unique）的约束，故报错
		mysql> insert into t_vip(id,name) values(2,'wangwu');
		ERROR 1062 (23000): Duplicate entry '2' for key 't_vip.PRIMARY'
		mysql> select * from t_vip;
		+----+----------+
		| id | name     |
		+----+----------+
		|  1 | zhangsan |
		|  2 | lisi     |
		+----+----------+
		2 rows in set (0.00 sec)
		
		// 插入记录，id为null，会受到主键（not null）的约束，故报错
		mysql> insert into t_vip(name) values('wangwu');
		ERROR 1364 (HY000): Field 'id' doesn't have a default value
	
	可以这样添加主键吗？
		drop table if exists t_vip;
		create table t_vip(
			id int,
			name varchar(255),
			primary key(id)
		);
		insert into t_vip values(1,'shangsan');
		insert into t_vip values(1,'shangsan');
		
		// 可以通过表级约束添加主键
		mysql> drop table if exists t_vip;
		Query OK, 0 rows affected, 1 warning (0.01 sec)

		mysql> create table t_vip(
			-> id int,
			-> name varchar(255),
			-> primary key(id)
			-> );
		Query OK, 0 rows affected (0.01 sec)

		mysql> insert into t_vip values(1,'shangsan');
		Query OK, 1 row affected (0.00 sec)

		mysql> insert into t_vip values(1,'shangsan');
		ERROR 1062 (23000): Duplicate entry '1' for key 't_vip.PRIMARY'
		
		表级约束是给多个字段联合起来添加约束？
		// id 和 name 联合起来作主键，叫做复合主键
		drop table if exists t_vip;
		create table t_vip(
			id int,
			name varchar(255),
			email varchar(255),
			primary key(id,name)
		);
		
		insert into t_vip values(1,'shangsan','zhangsan@qq.com');
		insert into t_vip values(1,'lisi','lisi@qq.com');
		insert into t_vip(name,email) values('wangwu','wangwu@qq.com');
		insert into t_vip(id,email) values(2,'wangwu@qq.com');
		insert into t_vip(email) values('123@qq.com');
		
		insert into t_vip values(1,'shangsan');
		
		//
		mysql> drop table if exists t_vip;
		Query OK, 0 rows affected (0.01 sec)

		mysql> create table t_vip(
			-> id int,
			-> name varchar(255),
			-> email varchar(255),
			-> primary key(id,name)
			-> );
		Query OK, 0 rows affected (0.02 sec)
		
		// 虽然id都是1，但是id和name联合起来就不会重复了
		mysql>
		mysql> insert into t_vip values(1,'shangsan','zhangsan@qq.com');
		Query OK, 1 row affected (0.00 sec)

		mysql> insert into t_vip values(1,'lisi','lisi@qq.com');
		Query OK, 1 row affected (0.00 sec)

		mysql> select * from t_vip;
		+----+----------+-----------------+
		| id | name     | email           |
		+----+----------+-----------------+
		|  1 | lisi     | lisi@qq.com     |
		|  1 | shangsan | zhangsan@qq.com |
		+----+----------+-----------------+
		2 rows in set (0.00 sec)
		
		// id和name联合起来出现重复，就会报错
		mysql> insert into t_vip values(1,'lisi','lisi@qq.com');
		ERROR 1062 (23000): Duplicate entry '1-lisi' for key 't_vip.PRIMARY'
		
		在实际开发中，不建议使用复合主键，建议使用单一主键。
		因为主键值存在的意义就是这行记录的身份证号码，只要意义达到，单一主键就可以做到
		复合主键比较复杂，不建议使用
		
		一个表中，主键约束可以加多个吗？
		drop table if exists t_vip;
		create table t_vip(
			id int primary key,
			name varchar(255) primary key,
			email varchar(255)
		);
		
		// 结论：一张表中，主键约束只能添加1个，主键只能有1个
		mysql> drop table if exists t_vip;
		Query OK, 0 rows affected (0.02 sec)

		mysql> create table t_vip(
			-> id int primary key,
			-> name varchar(255) primary key,
			-> email varchar(255)
			-> );
		ERROR 1068 (42000): Multiple primary key defined
		
		主键值建议使用：
			int
			bigint
			char
			等类型
			不建议使用varchar来做主键，主键值一般都是数字，一般都是定长的
		
		主键除了单一主键和复合主键，还可以这样进行分类？
			自然主键：主键值是一个自然数，和业务没关系
			业务主键：主键值和业务密切相关，例如拿银行卡号作为主键值，这就是业务主键
			
			在实际开发中，使用业务主键多还是自然主键多？
				答案是：自然主键。因为主键只要做到不重复就行，不需要有意义。
				业务主键不好，因为主键一旦和业务挂钩，那么当业务发生变动的时候，
				可能会影响到主键值，所以业务主键不建议使用。尽量使用自然主键
			
			在MySQL当中，有一种机制，可以帮助我们自动维护一个主键值？
			drop table if exists t_vip;
			create table t_vip(
				id int primary key auto_increment,
				name varchar(255)
			);
			
			insert into t_vip(name) values('zhangsan');
			insert into t_vip(name) values('zhangsan');
			insert into t_vip(name) values('zhangsan');
			insert into t_vip(name) values('zhangsan');
			insert into t_vip(name) values('zhangsan');
			insert into t_vip(name) values('zhangsan');
			
			select * from t_vip;
			
			// 在主键后面增加auto_increment关键字
			
			mysql> drop table if exists t_vip;
			Query OK, 0 rows affected, 1 warning (0.01 sec)

			mysql> create table t_vip(
				-> id int primary key auto_increment,
				-> name varchar(255)
				-> );
			Query OK, 0 rows affected (0.02 sec)

			mysql>
			mysql> insert into t_vip(name) values('zhangsan');
			Query OK, 1 row affected (0.00 sec)

			mysql> insert into t_vip(name) values('zhangsan');
			Query OK, 1 row affected (0.00 sec)

			mysql> insert into t_vip(name) values('zhangsan');
			Query OK, 1 row affected (0.01 sec)

			mysql> insert into t_vip(name) values('zhangsan');
			Query OK, 1 row affected (0.00 sec)

			mysql> insert into t_vip(name) values('zhangsan');
			Query OK, 1 row affected (0.00 sec)

			mysql> insert into t_vip(name) values('zhangsan');
			Query OK, 1 row affected (0.00 sec)

			mysql>
			mysql> select * from t_vip;
			+----+----------+
			| id | name     |
			+----+----------+
			|  1 | zhangsan |
			|  2 | zhangsan |
			|  3 | zhangsan |
			|  4 | zhangsan |
			|  5 | zhangsan |
			|  6 | zhangsan |
			+----+----------+
			6 rows in set (0.00 sec)
			
		auto_increment表示自增，从1开始，以1递增

	6.外键约束：foreign key(简称FK) 非常重要
		外键约束涉及到的相关术语：
			外键约束：foreign key 一种约束
			外键字段：该字段上添加了外键约束
			外键值：外键字段当中的每一个值
		
		业务背景：请设计数据库表，来描述学生和班级的信息
		
		第一种方案：班级和学生存储在一张表中
		no(pk)			name			classno			classname
		----------------------------------------------------------------------------------
		1				'jack'			100			北京市大兴区亦庄镇第二中学高三1班
		2				'lucy'			100			北京市大兴区亦庄镇第二中学高三1班
		3				'lilei'			100			北京市大兴区亦庄镇第二中学高三1班
		4				'hanmeimei'		100			北京市大兴区亦庄镇第二中学高三1班
		5				'zhangsan'		101			北京市大兴区亦庄镇第二中学高三2班
		6				'lisi'			101			北京市大兴区亦庄镇第二中学高三2班
		7				'wangwu'		101			北京市大兴区亦庄镇第二中学高三2班
		8				'zhaoliu'		101			北京市大兴区亦庄镇第二中学高三2班
		
		分析以上方案的缺点：
			数据冗余，空间浪费
			这个设计是比较失败的
		
		第二种方案：班级一张表，学生一张表
		
		t_class 班级表
		classno(pk)			classname
		------------------------------
		100			北京市大兴区亦庄镇第二中学高三1班
		101			北京市大兴区亦庄镇第二中学高三2班
		
		t_student 学生表
		no(pk)			name			cno(班级编号)
		-----------------------------------------
		1				'jack'			100
		2				'lucy'			100
		3				'lilei'			100
		4				'hanmeimei'		100
		5				'zhangsan'		101
		6				'lisi'			101
		7				'wangwu'		101
		8				'zhaoliu'		101
		
		当cno字段没有任何约束的时候，可能会导致数据无效。可能会出现一个102，但是102班级不存在
		所以为了保证cno字段中的值都是100和101，需要给cno字段添加外键约束
		那么，cno字段就是外键约束，cno字段中的每一个值都是外键值
		
		注意：
			t_class是父表，t_student是子表
			删除表的顺序？ 先删子表，再删父表
			创建表的顺序？ 先建父表，再建子表
			删除数据的顺序？先删子表，再删父表
			插入数据的顺序？先插父表，再插子表
		
		drop table if exists t_student;
		drop table if exists t_class;
		
		create table t_class(
			classno int primary key,
			classname varchar(255)
		);
		
		create table t_student(
			no int primary key auto_increment,
			name varchar(255),
			cno int,
			foreign key(cno) references t_class(classno)
		);
		
		insert into t_class values(100,'北京市大兴区亦庄镇第二中学高三1班');
		insert into t_class values(101,'北京市大兴区亦庄镇第二中学高三2班');
		
		insert into t_student(name,cno) values('jack',100);
		insert into t_student(name,cno) values('lucy',100);
		insert into t_student(name,cno) values('lilei',100);
		insert into t_student(name,cno) values('hanmeimei',100);
		insert into t_student(name,cno) values('zhangsan',101);
		insert into t_student(name,cno) values('lisi',101);
		insert into t_student(name,cno) values('wangwu',101);
		insert into t_student(name,cno) values('zhaoliu',101);
		
		select * from t_student;
		select * from t_class;
		
		mysql> select * from t_class;
		+---------+---------------------------------------------------+
		| classno | classname                                         |
		+---------+---------------------------------------------------+
		|     100 | 北京市大兴区亦庄镇第二中学高三1班                 |
		|     101 | 北京市大兴区亦庄镇第二中学高三2班                 |
		+---------+---------------------------------------------------+

		mysql> select * from t_student;
		+----+-----------+------+
		| NO | NAME      | cno  |
		+----+-----------+------+
		|  1 | jack      |  100 |
		|  2 | lucy      |  100 |
		|  3 | lilei     |  100 |
		|  4 | hanmeimei |  100 |
		|  5 | zhangsan  |  101 |
		|  6 | lisi      |  101 |
		|  7 | wangwu    |  101 |
		|  8 | zhaoliu   |  101 |
		+----+-----------+------+
		8 rows in set (0.00 sec)
		
		t_student使用外键后，cno的键值就只能在100和101之间选择。
		
		思考一下：子表中的外键引用的父表中的某个字段，被引用的这个字段必须是主键吗？
			答案是：被引用的这个字段不一定是主键，但是必须具有唯一性。至少具有unique约束
		 
		思考：外键值可以为null吗？
			答案是：可以，也就是t_student中的cno可以为null
			mysql> insert into t_student(name) values ('xiaohong');
			Query OK, 1 row affected (0.01 sec)
			
			mysql> select * from t_student;
			+----+-----------+------+
			| NO | NAME      | cno  |
			+----+-----------+------+
			|  1 | jack      |  100 |
			|  2 | lucy      |  100 |
			|  3 | lilei     |  100 |
			|  4 | hanmeimei |  100 |
			|  5 | zhangsan  |  101 |
			|  6 | lisi      |  101 |
			|  7 | wangwu    |  101 |
			|  8 | zhaoliu   |  101 |
			|  9 | xiaohong  | NULL |
			+----+-----------+------+
			9 rows in set (0.00 sec)
		
		为什么外键可以为null？
			ORACLE里的外键也允许为空，一般用处不大但也不能说完全没用。
			举个例子，公司新采购一批电脑，主键为主表.电脑ID，
			外键为子表.员工ID，如果电脑暂时还没有归属人，员工ID可以默认为NULL

6.存储引擎
	1.什么是存储引擎？有什么作用？
		存储引擎：MySQL中特有的一个术语，其他数据库中没有。（Oracle中有，但是不叫这个名字）
		实际上存储引擎是一个表，存储/组织数据的方式
		不同的存储引擎，表存储的方式会有不同
	2.怎么给表添加/指定存储引擎？
		show create table t_student;
		可以在建表的时候给表指定存储引擎。
		t_student | CREATE TABLE `t_student` (
		  `NO` int NOT NULL AUTO_INCREMENT,
		  `NAME` varchar(255) DEFAULT NULL,
		  `cno` int DEFAULT NULL,
		  PRIMARY KEY (`NO`),
		  KEY `cno` (`cno`),
		  CONSTRAINT `t_student_ibfk_1` FOREIGN KEY (`cno`) REFERENCES `t_class` (`classno`)
		) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8
		
		在建表的时候，可以在最后小括号的')'的右边使用：
			ENGINE用来指定存储引擎
			CHARSET用来指定字符编码方式
		
		结论：
			MySQL默认的存储引擎是：InnoDB
			MySQL默认的字符编码方式为：uft8
		
		建表时指定存储引擎以及字符编码方式
		
		drop table if exists t_product;
		create table t_product(
			id int primary key,
			name varchar(255)
		)engine = InnoDB default charset = gbk;
	
	3.MySQL支持哪些存储引擎？
		命令：show engines \g 注意不加分号
		mysql> show engines \g
		+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
		| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
		+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
		| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
		| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
		| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
		| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
		| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
		| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
		| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
		| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
		| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
		+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
		9 rows in set (0.00 sec)
		
		// 当前数据库版本
		mysql> select version();
		+-----------+
		| version() |
		+-----------+
		| 8.0.24    |
		+-----------+
		1 row in set (0.00 sec)
		
		MySQL支持9大存储引擎，当前8.0.24支持8个存储引擎。版本不同，支持情况不同
	
	4.关于MySQL中常用的存储引擎？
		MYISAM存储引擎？
			它管理的表具有以下特征：使用三个文件表示每个表：
				格式文件 - 存储表结构的定义（mytable.frm）
				数据文件 - 存储表行的内容（mytable.MYD）
				索引文件 - 存储表上索引（mytable.MYI） 索引，相当于一本书的目录，缩小扫描范围，提高查询效率的机制
			可被转换为压缩、只读表来节省空间
			
			提示一下：对于一张表来说，只要是主键，
				或者加有unique约束的字段上就会自动创建索引
			
			MyISAM存储引擎的特点：
				可被转换为压缩、只读表来节省空间
			MyISAM不支持事务，安全性很低
			
			drop table if exists t1;
			create table t1(
				no int primary key,
				name varchar(255),
				email varchar(255)
			) engine = MyISAM default charset = utf8;
			
			mysql> drop table if exists t1;
			Query OK, 0 rows affected (0.01 sec)

			mysql> create table t1(
				-> no int primary key,
				-> name varchar(255),
				-> email varchar(255)
				-> ) engine = MyISAM default charset = utf8;
			Query OK, 0 rows affected, 1 warning (0.01 sec)

			mysql> show create table t1;
			+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
			| Table | Create Table                                                                                                                                                                    |
			+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
			| ttt   | CREATE TABLE `t1` (
			  `no` int NOT NULL,
			  `name` varchar(255) DEFAULT NULL,
			  `email` varchar(255) DEFAULT NULL,
			  PRIMARY KEY (`no`)
			) ENGINE=MyISAM DEFAULT CHARSET=utf8mb3 |
			+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
			1 row in set (0.00 sec)
			
		InnoDB存储引擎？
			这是MySQL默认的存储引擎，同时也是一个重量级的存储引擎。
			InnoDB支持事务，支持数据库崩溃后的自动恢复机制。
			InnoDB最主要的特点是非常安全。
			
			drop table if exists t2;
			create table t2(
				no int primary key,
				name varchar(255),
				email varchar(255)
			) engine = InnoDB default charset = utf8;
			
			mysql> drop table if exists t2;
			Query OK, 0 rows affected, 1 warning (0.00 sec)

			mysql> create table t2(
				-> no int primary key,
				-> name varchar(255),
				-> email varchar(255)
				-> ) engine = InnoDB default charset = utf8;
			Query OK, 0 rows affected, 1 warning (0.02 sec)

			mysql> show create table t2;
			+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
			| Table | Create Table                                                                                                                                                                   |
			+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
			| t2    | CREATE TABLE `t2` (
			  `no` int NOT NULL,
			  `name` varchar(255) DEFAULT NULL,
			  `email` varchar(255) DEFAULT NULL,
			  PRIMARY KEY (`no`)
			) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 |
			+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
			1 row in set (0.00 sec)
		
		它管理的表具有下列主要特征：
			C 每个 InnoDB 表在数据库目录中以 .frm 格式文件表示
			C InnoDB 表空间 tablespace 被用于存储表的内容（表空间是一个逻辑名称。表空间存储数据+索引）
			C 提供一组用来记录事务性活动的日志文件
			C 用 COMMIT 提交 、 SAVEPOINT及ROLLBACK回滚，支持事务处理
			C 提供全 ACID 兼容
			C 在 MySQL 服务器崩溃后提供自动恢复
			C 多版本（ MVCC ）和行级锁定
			C 支持外键及引用的完整性 ，包括级联删除和更新
		
		InnoDB最大的特点就是支持事务：
			以保证数据的安全。效率不是很高，并且也不能压缩，不能转换为只读，
			不能很好地节省存储空间
			
		MEMORY存储引擎？
			MEMORY 存储引擎管理的表具有下列特征：
				C 在数据库目录内，每个表均以 .frm 格式的文件表示。
				C 表数据及索引 被存储在内存中。
				C 表级锁机制。
				C 不能包含 TEXT 或 BLOB 字段。
				
			drop table if exists t3;
			create table t3(
				no int primary key,
				name varchar(255),
				email varchar(255)
			) engine = MEMORY default charset = utf8;
			
			mysql> drop table if exists t3;
			Query OK, 0 rows affected, 1 warning (0.00 sec)

			mysql> create table t3(
				-> no int primary key,
				-> name varchar(255),
				-> email varchar(255)
				-> ) engine = MEMORY default charset = utf8;
			Query OK, 0 rows affected, 1 warning (0.01 sec)

			mysql> show create table t3;
			+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
			| Table | Create Table                                                                                                                                                                   |
			+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
			| t3    | CREATE TABLE `t3` (
			  `no` int NOT NULL,
			  `name` varchar(255) DEFAULT NULL,
			  `email` varchar(255) DEFAULT NULL,
			  PRIMARY KEY (`no`)
			) ENGINE=MEMORY DEFAULT CHARSET=utf8mb3 |
			+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
			1 row in set (0.00 sec)
			
			MEMORY 存储引擎以前被称为HEAP引擎。
			
			MEMORY引擎优点：查询效率是最高的。不需要和硬盘交互
			MEMORY引擎缺点：不安全，关机断电之后数据消失。因为数据和索引都是在内存中

7.事务（重点：五颗星*****，必须理解，必须掌握）
	1. 一个事务其实就是一个完整的业务逻辑。
		是一个最小的工作单元，不可再分。
	
		什么是一个完整的业务逻辑？
			假设转账，从A账户向B账户中转账10000.
			将A账户的钱减少10000 (update语句)
			将B账户的钱增加10000 (update语句)
			这就是一个完整的业务逻辑
			
			以上的操作是一个最小的工作单元，要么同时成功，要么同时失败，不可再分
			这两个update语句要求必须是同时成功或者同时失败，这样才能保证钱是正确的
	2.只有DML语句才会有事务一说，其他语句和事务无关
		insert
		delete
		update
		只有以上的三个语句和事务有关系，其他都没有关系
		
		因为 只有以上的三个语句是数据库表中数据进行增、删、改的
		只要操作一旦涉及到数据的增删改，那么就一定要考虑安全机制
		
		数据安全是第一位
	
	3.假设所有的业务，只要一条DML语句就能完成，还有必要存在事务机制吗？
		正是因为做某件事的时候，需要多条DML语句共同联合起来完成才能完成。
		所以需要事务的存在。
		
		如果任何一件事务都能一条DML语句就能搞定，那么事务就没有存在的价值了。
		
		到底什么是事务呢？
			说到底，本质上，一个事务就是多条DML语句同时成功或者同时失败。
			事务：就是批量的DML语句同时成功或者同时失败。
	
	4.事务是如何做到多条DML语句同时成功或者同时失败的呢？
		InnoDB存储引擎：提供一组用来记录事务性活动的日志文件
		事务开启：
			insert
			insert
			insert
			insert
			update
			update
			update
			delete
			delete
				...
		事务结束了.
		在事务的执行过程中，每一条DML的操作都会记录到"事务活动的日志文件"中。
		在事务的执行过程中，我们可以提交事务，也可以回滚事务。
		
		提交事务？commit
			清空事务性活动的日志文件，将数据的全部彻底持久化到数据库表当中。
			提交事务标志着事务的结束。并且是一种全部成功的结束。
		回滚事务？rollback
			将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件
			回滚事务标志着事务的结束，并且是一种全部失败的结束。
	
	5.怎么提交事务？怎么回滚事务？
		提交事务：commit语句
		回滚事务：rollback语句（回滚永远都是只能回滚到上一次的提交点）
		
		事务对应的英语单词：transaction
		
		测试一下，在MySQL中默认的事务行为是什么？
			MySQL默认情况下是支持自动提交事务的。（自动提交）
			什么是自动提交？
				每执行一条DML语句，则提交一次。
			这种自动提交实际上是不符合实际的而开发习惯的，因为一个业务
			通常是需要多条DML语句共同执行才能完成，所以为了保证数据的安全，
			必须要求同时成功之后在提交，所以不能执行一条就提交一条
		
		怎么将MySQL的自动提交机制关闭呢？
			先执行命令：start transaction;
		
		演示事务：
		mysql> use bjpowernode;
		Database changed
		mysql> select * from dept_cpy;
		Empty set (0.00 sec)
		
		---------------------------回滚事务案例1----------------------------------------------------------
		mysql> start transaction;
		Query OK, 0 rows affected (0.00 sec)

		mysql> insert into dept_cpy values(10,'abc','bj');
		Query OK, 1 row affected (0.00 sec)

		mysql> insert into dept_cpy values(10,'abc','bj');
		Query OK, 1 row affected (0.00 sec)

		mysql> insert into dept_cpy values(10,'abc','bj');
		Query OK, 1 row affected (0.00 sec)

		mysql> insert into dept_cpy values(10,'abc','bj');
		Query OK, 1 row affected (0.00 sec)

		mysql> select * from dept_cpy;
		+--------+-------+------+
		| DEPTNO | DNAME | LOC  |
		+--------+-------+------+
		|     10 | abc   | bj   |
		|     10 | abc   | bj   |
		|     10 | abc   | bj   |
		|     10 | abc   | bj   |
		+--------+-------+------+
		4 rows in set (0.00 sec)

		mysql> rollback;
		Query OK, 0 rows affected (0.00 sec)

		mysql> select * from dept_cpy;
		Empty set (0.00 sec)
		
		---------------------------回滚事务案例2----------------------------------------------------------
		// 起始状态
		mysql> select * from dept_cpy;
		+--------+-------+------+
		| DEPTNO | DNAME | LOC  |
		+--------+-------+------+
		|     10 | abc   | bj   |
		+--------+-------+------+
		1 row in set (0.00 sec)
		
		// 关闭自动提交事务
		mysql> start transaction;
		Query OK, 0 rows affected (0.00 sec)

		mysql> insert into dept_cpy values(20,'def','sx');
		Query OK, 1 row affected (0.00 sec)

		mysql> insert into dept_cpy values(20,'def','sx');
		Query OK, 1 row affected (0.00 sec)

		mysql> insert into dept_cpy values(20,'def','sx');
		Query OK, 1 row affected (0.00 sec)

		mysql> select * from dept_cpy;
		+--------+-------+------+
		| DEPTNO | DNAME | LOC  |
		+--------+-------+------+
		|     10 | abc   | bj   |
		|     20 | def   | sx   |
		|     20 | def   | sx   |
		|     20 | def   | sx   |
		+--------+-------+------+
		4 rows in set (0.00 sec)

		mysql> update dept_cpy set dname = 'salesman' where deptno = '20';
		Query OK, 3 rows affected (0.00 sec)
		Rows matched: 3  Changed: 3  Warnings: 0

		mysql> select * from dept_cpy;
		+--------+----------+------+
		| DEPTNO | DNAME    | LOC  |
		+--------+----------+------+
		|     10 | abc      | bj   |
		|     20 | salesman | sx   |
		|     20 | salesman | sx   |
		|     20 | salesman | sx   |
		+--------+----------+------+
		4 rows in set (0.00 sec)
		
		// 回滚
		mysql> rollback;
		Query OK, 0 rows affected (0.00 sec)
		
		// 可以回到起始状态
		mysql> select * from dept_cpy;
		+--------+-------+------+
		| DEPTNO | DNAME | LOC  |
		+--------+-------+------+
		|     10 | abc   | bj   |
		+--------+-------+------+
		1 row in set (0.00 sec)
		---------------------------回滚事务案例3----------------------------------------------------------
		// 起始状态
		mysql> select * from dept_cpy;
		+--------+-------+------+
		| DEPTNO | DNAME | LOC  |
		+--------+-------+------+
		|     10 | abc   | bj   |
		|     20 | def   | sx   |
		|     20 | def   | sx   |
		+--------+-------+------+
		3 rows in set (0.00 sec)
		
		// 关闭自动提交事务
		mysql> start transaction;
		Query OK, 0 rows affected (0.00 sec)
		
		// 事务-插入操作
		mysql> insert into dept_cpy values(20,'def','sx');
		Query OK, 1 row affected (0.00 sec)
		// 事务-插入操作
		mysql> insert into dept_cpy values(20,'def','sx');
		Query OK, 1 row affected (0.00 sec)
		// 事务-插入操作
		mysql> insert into dept_cpy values(20,'def','sx');
		Query OK, 1 row affected (0.00 sec)
		// 事务-修改操作
		mysql> update dept_cpy set dname = 'salesman' where deptno = '20';
		Query OK, 5 rows affected (0.00 sec)
		Rows matched: 5  Changed: 5  Warnings: 0

		mysql> select * from dept_cpy;
		+--------+----------+------+
		| DEPTNO | DNAME    | LOC  |
		+--------+----------+------+
		|     10 | abc      | bj   |
		|     20 | salesman | sx   |
		|     20 | salesman | sx   |
		|     20 | salesman | sx   |
		|     20 | salesman | sx   |
		|     20 | salesman | sx   |
		+--------+----------+------+
		6 rows in set (0.00 sec)
		
		// 事务-删除操作
		mysql> delete from dept_cpy where deptno='10';
		Query OK, 1 row affected (0.00 sec)

		mysql> select * from dept_cpy;
		+--------+----------+------+
		| DEPTNO | DNAME    | LOC  |
		+--------+----------+------+
		|     20 | salesman | sx   |
		|     20 | salesman | sx   |
		|     20 | salesman | sx   |
		|     20 | salesman | sx   |
		|     20 | salesman | sx   |
		+--------+----------+------+
		5 rows in set (0.00 sec)
		
		// 满足客户需求，则提交一次commit，事务成功。
		// 否则回滚，撤销事务的全部操作，事务失败
		mysql> rollback;
		Query OK, 0 rows affected (0.03 sec)

		mysql> select * from dept_cpy;
		+--------+-------+------+
		| DEPTNO | DNAME | LOC  |
		+--------+-------+------+
		|     10 | abc   | bj   |
		|     20 | def   | sx   |
		|     20 | def   | sx   |
		+--------+-------+------+
		3 rows in set (0.00 sec)
		
		---------------提交事务----------------------------------------------------------
		// 起始状态
		mysql> select * from dept_cpy;
		+--------+-------+------+
		| DEPTNO | DNAME | LOC  |
		+--------+-------+------+
		|     10 | abc   | bj   |
		+--------+-------+------+
		1 row in set (0.00 sec)
		
		// 关闭自动提交事务
		mysql> start transaction;
		Query OK, 0 rows affected (0.00 sec)

		mysql> insert into dept_cpy values(20,'def','sx');
		Query OK, 1 row affected (0.00 sec)

		mysql> insert into dept_cpy values(20,'def','sx');
		Query OK, 1 row affected (0.00 sec)

		mysql> insert into dept_cpy values(20,'def','sx');
		Query OK, 1 row affected (0.00 sec)
		
		// 提交事务
		mysql> commit;
		Query OK, 0 rows affected (0.01 sec)

		mysql> select * from dept_cpy;
		+--------+-------+------+
		| DEPTNO | DNAME | LOC  |
		+--------+-------+------+
		|     10 | abc   | bj   |
		|     20 | def   | sx   |
		|     20 | def   | sx   |
		|     20 | def   | sx   |
		+--------+-------+------+
		4 rows in set (0.00 sec)
		
		// 回滚
		mysql> rollback;
		Query OK, 0 rows affected (0.00 sec)
		
		// 无法回滚到起始状态
		mysql> select * from dept_cpy;
		+--------+-------+------+
		| DEPTNO | DNAME | LOC  |
		+--------+-------+------+
		|     10 | abc   | bj   |
		|     20 | def   | sx   |
		|     20 | def   | sx   |
		|     20 | def   | sx   |
		+--------+-------+------+
		4 rows in set (0.00 sec)
	
	6.事务包括4个特性。
		A:原子性
			说明事务是最小的工作单元，不可再分
		
		C:一致性
			在同一个事务当中，所有的操作必须同时成功，或者同时失败
			以保证数据的一致性
		
		I:隔离性
			A事务和B事务之间具有一定的隔离
			教室A和教室B之间有一道墙，这道墙就是隔离性
			A事务在操作一张表的时候，另一个事务B也在操作这个表
			多线程并发操作这张表
			
		D:持久性
			事务最终结束的一个保障。
			事务提交，就相当于将没有保存到硬盘上的数据保存到硬盘上
		
	7.重点研究事务的隔离性
		教室A和教室B之间有一道墙，这道墙可以很厚，也可以很薄，这就是事务的隔离级别
		隔离级别越高，表示这道墙越厚。
		事务和事务之间的隔离级别：
			读未提交：read uncommitted(最低的隔离级别) "没有提交就读到了"
				事务A可以读取到事务B未提交的数据
				这种隔离级别存在的问题就是：脏读现象（Dirty read）
				我们称读到了脏数据
				这种隔离级别一般都是理论上的，大多数的数据库的隔离级别二档起步
				
			读已提交：read committed "提交之后才能读到"
				事务A只能读取到事务B提交的数据
				这种隔离级别解决了什么问题？
					解决了脏读现象
				这种隔离级别存在什么问题？
					不可重复读取问题
				什么是不可重复读取数据？
					在事务开启之后，第一次读到的数据是3条，当前事务还没有结束
					可能第二次在读取的时候，读到的数据是4条，3不等于4，
					称为不可重复读取
				
				这种隔离级别是比较真实的数据，每一次读到的数据是绝对的真实
				Oracle数据库默认的隔离级别是：读已提交
				
			可重复读：repeatable read  "提交之后也读不到，永远读取的时候都是刚开始事务时的数据"
				事务A开启之后，不管是多久，每次在事务A中读取到的数据都是一致的
				即使事务B将数据修改，并且已经提交，事务A读取到的数据还是没有发生改变
				这就是可重复读取
				
				可重复读解决了什么问题？
					可重复读解决了不可不可重复读的问题
				
				可重复读存在的问题：
					可能会出现幻影读
					每一次读到的数据都是幻象，不够真实
				
				早上9点B开启了事务，只要事务B不结束，到晚上9点，事务A读到的数据还是那样，也就是最初状态的数据
				读到的是假象，不够绝对的真实
				
				MySQL中事务默认的隔离级别事务：可重复读
				
			序列化/串行化：serializable(最高的隔离级别)
				这是最高隔离级别，效率最低。解决了所有问题
				这种隔离级别表示事务排队，不能并发
				有点类似于：synchronized，线程同步
				每一次读取到的数据都是最真实的，但是效率是最低的
			
	8.验证各种隔离级别
		查看当前的事务隔离级别：
			执行语句：select @@transaction_isolation;
			mysql> select @@transaction_isolation;
			+-------------------------+
			| @@transaction_isolation |
			+-------------------------+
			| REPEATABLE-READ         |
			+-------------------------+
			1 row in set (0.00 sec)
			这是MySQL默认的事务隔离级别
			
			设置当前事务的事务隔离等级：
				mysql> set global transaction isolation level read uncommitted;
				Query OK, 0 rows affected (0.00 sec)
				
				或者
				SET transaction_isolation = 'READ-UNCOMMITTED';
				
				或
				SET SESSION transaction_isolation = 'READ-UNCOMMITTED';
			
		被测试的表是t_user;
		
		1.验证：read uncommitted
		
		mysql> set global transaction isolation level read uncommitted;
		
		事务A										事务B
		----------------------------------------------------
		use bjpowernode;							
													use bjpowernode;											
		start transaction;							
													start transaction;
		select * from t_user;(空表)					
													insert into t_user values('zhangsan');
		select * from t_user;(B事务没有提交，但是可以查到t_user的数据)
		
		事务A的操作：
			mysql> use bjpowernode;
			Database changed
			mysql> start transaction;
			Query OK, 0 rows affected (0.00 sec)

			mysql> select * from t_user;
			Empty set (0.00 sec)

			mysql> select * from t_user;
			+----------+
			| name     |
			+----------+
			| zhangsan |
			+----------+
			1 row in set (0.00 sec)
		
		事务B的操作：
		mysql> use bjpowernnode;
		
		Query OK, 0 rows affected (0.00 sec)
		mysql> use bjpowernode;
		Database changed
		mysql> start transaction;
		Query OK, 0 rows affected (0.00 sec)

		mysql> insert into t_user values('zhangsan');
		Query OK, 1 row affected (0.00 sec)
		
		2.验证：read committed
		
		mysql> set transaction_isolation = 'read-committed';
		
		事务A										事务B
		----------------------------------------------------
		use bjpowernode;							
													use bjpowernode;													
		start transaction;							
													start transaction;
		select * from t_user;(空表)					
													insert into t_user values('zhangsan');
		select * from t_user;(空表)					
													commit;
		select * from t_user;(B事务commit提交后，可以查到t_user的数据)
		
		事务A的操作：
		mysql> use bjpowernode;
		Database changed
		mysql> start transaction;
		Query OK, 0 rows affected (0.00 sec)

		mysql> select @@transaction_isolation;
		+-------------------------+
		| @@transaction_isolation |
		+-------------------------+
		| READ-COMMITTED          |
		+-------------------------+
		1 row in set (0.00 sec)
		
		// 初始状态 t_user为空表
		mysql> select * from t_user;
		Empty set (0.00 sec)
		
		// 事务B已经往t_user插入了记录，但是没有提交
		// 由于事务隔离等级为read committed， 此时事务A无法查询到B提交的记录
		mysql> select * from t_user;
		Empty set (0.00 sec)
		
		// 事务B提交了记录，此时事务A方可查询到B提交的记录
		mysql> select * from t_user;
		+----------+
		| name     |
		+----------+
		| zhangsan |
		+----------+
		1 row in set (0.00 sec)
		
		事务B的操作：
		mysql> use bjpowernode;
		Database changed
		mysql> start transaction;
		Query OK, 0 rows affected (0.00 sec)

		Query OK, 0 rows affected (0.00 sec)

		mysql> select * from t_user;
		Empty set (0.00 sec)
		
		mysql> insert into t_user values ('zhangsan');
		Query OK, 1 row affected (0.00 sec)

		mysql> select * from t_user;
		+----------+
		| name     |
		+----------+
		| zhangsan |
		+----------+
		1 row in set (0.00 sec)

		mysql> commit;
		Query OK, 0 rows affected (0.01 sec)
		
		3.验证：repeatable read
		
		mysql> set global transaction isolation level repeatable read;
		
		事务A										事务B
		----------------------------------------------------
		use bjpowernode;							
													use bjpowernode;													
		start transaction;							
													start transaction;
		select * from t_user;(初始记录)				
													insert into t_user values('lisi');
													insert into t_user values('lisi');
													insert into t_user values('lisi');
													insert into t_user values('lisi');
													insert into t_user values('lisi');
		select * from t_user;(记录不变)				
													commit;
		select * from t_user;(记录不变)								
													insert into t_user values('jack');
													insert into t_user values('tom');
													commit;
		select * from t_user;(记录不变)
													insert into t_user values('wangwu');													insert into t_user values('tom');
													commit;
		select * from t_user;(记录不变)
		
	事务A的操作：
		mysql> use bjpowernode;
		Database changed
		mysql> start transaction;
		Query OK, 0 rows affected (0.00 sec)

		mysql> start transaction;
		Query OK, 0 rows affected (0.00 sec)
		
		// 第一次提交的数据
		mysql> select * from t_user;
		+----------+
		| name     |
		+----------+
		| zhangsan |
		+----------+
		1 row in set (0.00 sec)

		mysql> select * from t_user;
		+----------+
		| name     |
		+----------+
		| zhangsan |
		+----------+
		1 row in set (0.00 sec)

		mysql> select * from t_user;
		+----------+
		| name     |
		+----------+
		| zhangsan |
		+----------+
		1 row in set (0.00 sec)

		mysql> select * from t_user;
		+----------+
		| name     |
		+----------+
		| zhangsan |
		+----------+
		1 row in set (0.00 sec)

		mysql> select * from t_user;
		+----------+
		| name     |
		+----------+
		| zhangsan |
		+----------+
		1 row in set (0.00 sec)
		
		// 事务B已经往t_user插入了记录，并且提交
		// 但是事务A查询到的记录不变
		mysql> select * from t_user;
		+----------+
		| name     |
		+----------+
		| zhangsan |
		+----------+
		1 row in set (0.00 sec)
		
		事务B的操作：
			mysql> use bjpowernode;
			Database changed
			
			Query OK, 0 rows affected (0.00 sec)

			mysql> start transaction;
			Query OK, 0 rows affected (0.00 sec)

			mysql> select * from t_user;
			+----------+
			| name     |
			+----------+
			| zhangsan |
			+----------+
			1 row in set (0.00 sec)

			mysql> insert into t_user values('lisi');
			Query OK, 1 row affected (0.00 sec)

			mysql> insert into t_user values('lisi');
			Query OK, 1 row affected (0.00 sec)

			mysql> insert into t_user values('lisi');
			Query OK, 1 row affected (0.00 sec)

			mysql> insert into t_user values('lisi');
			Query OK, 1 row affected (0.00 sec)

			mysql> insert into t_user values('lisi');
			Query OK, 1 row affected (0.00 sec)

			mysql> select * from t_user;
			+----------+
			| name     |
			+----------+
			| zhangsan |
			| lisi     |
			| lisi     |
			| lisi     |
			| lisi     |
			| lisi     |
			+----------+
			6 rows in set (0.00 sec)

			mysql> commit;
			Query OK, 0 rows affected (0.00 sec)

			mysql> insert into t_user values('jack');
			Query OK, 1 row affected (0.00 sec)

			mysql> insert into t_user values('tom');
			Query OK, 1 row affected (0.00 sec)

			mysql> commit;
			Query OK, 0 rows affected (0.00 sec)

			mysql> insert into t_user values('wangwu');
			Query OK, 1 row affected (0.01 sec)

			mysql> commit;
			Query OK, 0 rows affected (0.00 sec)
		
		4.验证：serializable
		
		mysql> set global transaction isolation level serializable;
		
		事务A										事务B
		----------------------------------------------------
		use bjpowernode;							
													use bjpowernode;
		start transaction;							
													start transaction;
		select * from t_user;(初始记录)
		insert into t_user values('lisi');
													select * from t_user;
		commit;
		start transaction;
													start transaction;
													insert into t_user values('wangwu');
		select * from t_user;
													commit;
													
		事务A的操作：
			mysql> use bjpowernode;
			Database changed
			mysql> select * from t_user;
			+------+
			| name |
			+------+
			| abc  |
			+------+
			1 row in set (0.00 sec)

			mysql> start transaction;
			Query OK, 0 rows affected (0.00 sec)

			mysql> select * from t_user;
			+------+
			| name |
			+------+
			| abc  |
			+------+
			1 row in set (0.00 sec)

			mysql> insert into t_user values('lisi');
			Query OK, 1 row affected (0.00 sec)

			mysql> commit;
			Query OK, 0 rows affected (0.01 sec)

			mysql> start transaction;
			Query OK, 0 rows affected (0.00 sec)

			mysql> select * from t_user;
			+--------+
			| name   |
			+--------+
			| abc    |
			| lisi   |
			| wangwu |
			+--------+
			3 rows in set (20.64 sec)
			
		事务B的操作：
		
		mysql> select @@transaction_isolation;
		+-------------------------+
		| @@transaction_isolation |
		+-------------------------+
		| SERIALIZABLE            |
		+-------------------------+
		1 row in set (0.00 sec)

		mysql> use bjpowernode;
		Database changed
		mysql> select * from t_user;
		+------+
		| name |
		+------+
		| abc  |
		+------+
		1 row in set (0.00 sec)

		mysql> start transaction;
		Query OK, 0 rows affected (0.00 sec)

		mysql> select * from t_user;
		+------+
		| name |
		+------+
		| abc  |
		| lisi |
		+------+
		2 rows in set (33.05 sec)

		mysql> start transaction;
		Query OK, 0 rows affected (0.00 sec)

		mysql> insert into t_user values('wangwu');
		Query OK, 1 row affected (0.00 sec)

		mysql> select * from t_user;
		+--------+
		| name   |
		+--------+
		| abc    |
		| lisi   |
		| wangwu |
		+--------+
		3 rows in set (0.00 sec)

		mysql> commit;
		Query OK, 0 rows affected (0.00 sec)