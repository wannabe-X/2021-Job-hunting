MySQL day02课堂笔记

1.把查询结果去除重复记录【distinct】
	注意：原表数据不会被删除，只是查询结果去重
	去重需要使用一个关键字：distinct
	
	案例：员工工作岗位去重，查看实际工作岗位
		mysql> select distinct job from emp;
		+-----------+
		| job       |
		+-----------+
		| CLERK     |
		| SALESMAN  |
		| MANAGER   |
		| ANALYST   |
		| PRESIDENT |
		+-----------+
		5 rows in set (0.00 sec)
		
	// 这样编写是错误的，语法错误
	// distinct只能出现在所有字段的前方
		mysql> select ename,distinct job from emp;
		ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'distinct job from emp' at line 1
	
	// distinct出现在job，deptno两个字段之前，表示两个字段联合起来去重
		mysql> select distinct deptno,job from emp;
		+--------+-----------+
		| deptno | job       |
		+--------+-----------+
		|     20 | CLERK     |
		|     30 | SALESMAN  |
		|     20 | MANAGER   |
		|     30 | MANAGER   |
		|     10 | MANAGER   |
		|     20 | ANALYST   |
		|     10 | PRESIDENT |
		|     30 | CLERK     |
		|     10 | CLERK     |
		+--------+-----------+
		9 rows in set (0.00 sec)
	
	案例：统计一下工作岗位的数量？
		mysql> select count(distinct job) from emp;
		+---------------------+
		| count(distinct job) |
		+---------------------+
		|                   5 |
		+---------------------+
		1 row in set (0.00 sec)

2.连接查询
	1.什么是连接查询？
		从一张表中单独查询称为单表查询
		emp表和dept表联合起来查数据，从emp表中取员工名字，从dept表中取部门名字
		这种跨表查询，多张表联合起来查询数据，被称为多表查询
	2.连接查询的分类
		根据语法的年代分类：
			SQL92：1992年的时候出现的语法
			SQL99：1999年的时候出现的语法
		根据表连接的方式分类：
			内连接：
				等值连接
				非等值连接
				自连接
				
			外连接：
				左外连接：左连接
				右外连接：右连接
				
			全连接
	3.当两张表进行连接查询时，没有任何条件的限制，会发生什么现象？
		案例：查询每个员工所在部门名称？
			mysql> select ename,deptno from emp;
			+--------+--------+
			| ename  | deptno |
			+--------+--------+
			| SMITH  |     20 |
			| ALLEN  |     30 |
			| WARD   |     30 |
			| JONES  |     20 |
			| MARTIN |     30 |
			| BLAKE  |     30 |
			| CLARK  |     10 |
			| SCOTT  |     20 |
			| KING   |     10 |
			| TURNER |     30 |
			| ADAMS  |     20 |
			| JAMES  |     30 |
			| FORD   |     20 |
			| MILLER |     10 |
			+--------+--------+
			14 rows in set (0.00 sec)
			
			mysql> select * from dept;
			+--------+------------+----------+
			| DEPTNO | DNAME      | LOC      |
			+--------+------------+----------+
			|     10 | ACCOUNTING | NEW YORK |
			|     20 | RESEARCH   | DALLAS   |
			|     30 | SALES      | CHICAGO  |
			|     40 | OPERATIONS | BOSTON   |
			+--------+------------+----------+
			4 rows in set (0.00 sec)
		
		// 两表之间没有任何条件限制
				mysql> select ename,dname from emp,dept;
				+--------+------------+
				| ename  | dname      |
				+--------+------------+
				| SMITH  | OPERATIONS |
				| SMITH  | SALES      |
				| SMITH  | RESEARCH   |
				| SMITH  | ACCOUNTING |
				| ALLEN  | OPERATIONS |
				| ALLEN  | SALES      |
				| ALLEN  | RESEARCH   |
				| ALLEN  | ACCOUNTING |
				......
				56 rows in set (0.00 sec)
				14 * 4 = 56
		// 当两张表进行连接查询，没有任何条件限制的时候，最终查询价格的条数
		是两张表条数的乘积，这种现象称为：笛卡尔积现象(笛卡尔发现的一种数学现象)
	4.怎么避免笛卡尔积现象？
		连接时加条件，满足这个条件的记录被筛选出来
			mysql> select ename,dname from emp,dept where emp.deptno=dept.deptno;
			+--------+------------+
			| ename  | dname      |
			+--------+------------+
			| SMITH  | RESEARCH   |
			| ALLEN  | SALES      |
			| WARD   | SALES      |
			| JONES  | RESEARCH   |
			| MARTIN | SALES      |
			| BLAKE  | SALES      |
			| CLARK  | ACCOUNTING |
			| SCOTT  | RESEARCH   |
			| KING   | ACCOUNTING |
			| TURNER | SALES      |
			| ADAMS  | RESEARCH   |
			| JAMES  | SALES      |
			| FORD   | RESEARCH   |
			| MILLER | ACCOUNTING |
			+--------+------------+
			14 rows in set (0.00 sec)
			
			思考：最终查询的结果条数是14，但是匹配的过程中，匹配的次数减少了吗？
			答案是没有，匹配的次数还是14*4=56次，只不过进行了四选一，次数没有减少
		
		// 给表起别名，很重要(SQL92语法)
			mysql> select e.ename,d.dname from emp e,dept d where e.deptno=d.deptno;
			+--------+------------+
			| ename  | dname      |
			+--------+------------+
			| SMITH  | RESEARCH   |
			| ALLEN  | SALES      |
			| WARD   | SALES      |
			| JONES  | RESEARCH   |
			| MARTIN | SALES      |
			| BLAKE  | SALES      |
			| CLARK  | ACCOUNTING |
			| SCOTT  | RESEARCH   |
			| KING   | ACCOUNTING |
			| TURNER | SALES      |
			| ADAMS  | RESEARCH   |
			| JAMES  | SALES      |
			| FORD   | RESEARCH   |
			| MILLER | ACCOUNTING |
			+--------+------------+
			14 rows in set (0.00 sec)
		
		通过笛卡尔积现象得出，表的连接次数越多效率就越低，尽量避免表的连接次数
	
	5.内连接-等值连接
		查询每个员工所在的部门名称，显示员工名和部门名？
		emp e和dept d表进行连接。条件是：e.deptno = d.deptno
		
		SQL92语法：
			mysql> select e.ename,d.dname from emp e,dept d where e.deptno=d.deptno;
			+--------+------------+
			| ename  | dname      |
			+--------+------------+
			| SMITH  | RESEARCH   |
			| ALLEN  | SALES      |
			| WARD   | SALES      |
			| JONES  | RESEARCH   |
			| MARTIN | SALES      |
			| BLAKE  | SALES      |
			| CLARK  | ACCOUNTING |
			| SCOTT  | RESEARCH   |
			| KING   | ACCOUNTING |
			| TURNER | SALES      |
			| ADAMS  | RESEARCH   |
			| JAMES  | SALES      |
			| FORD   | RESEARCH   |
			| MILLER | ACCOUNTING |
			+--------+------------+
			14 rows in set (0.00 sec)
		SQL92的缺点：结构不清晰，表的连接条件，和后期进一步筛选的条件，都放到了where后面
		
		SQL99语法：
			// emp e inner join dept d，inner可以省略，带inner可读性更好，一眼就能看出来是内连接
			// on e.deptno=d.deptno，条件是等量关系，所以被称为等值连接
			mysql> select e.ename,d.dname from emp e inner join dept d on e.deptno=d.deptno;
			+--------+------------+
			| ename  | dname      |
			+--------+------------+
			| SMITH  | RESEARCH   |
			| ALLEN  | SALES      |
			| WARD   | SALES      |
			| JONES  | RESEARCH   |
			| MARTIN | SALES      |
			| BLAKE  | SALES      |
			| CLARK  | ACCOUNTING |
			| SCOTT  | RESEARCH   |
			| KING   | ACCOUNTING |
			| TURNER | SALES      |
			| ADAMS  | RESEARCH   |
			| JAMES  | SALES      |
			| FORD   | RESEARCH   |
			| MILLER | ACCOUNTING |
			+--------+------------+
			14 rows in set (0.00 sec)
		SQL99的优点：表连接的条件是独立的，连接之后，
			如果还需要进一步的筛选，再往后继续where 
		SQL99语法：
			select
				...
			from
				a
			join
				b
			on
				a和b的连接条件
			where
				筛选条件
				
	6.内连接-非等值连接
		案例：找出每个员工的薪资等级，要求显示员工名、薪资、薪资等级？
			// on e.sal between s.losal and s.hisal，条件不是等值连接，称为非等值连接
			mysql> select e.ename,e.sal,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;
			+--------+---------+-------+
			| ename  | sal     | grade |
			+--------+---------+-------+
			| SMITH  |  800.00 |     1 |
			| ALLEN  | 1600.00 |     3 |
			| WARD   | 1250.00 |     2 |
			| JONES  | 2975.00 |     4 |
			| MARTIN | 1250.00 |     2 |
			| BLAKE  | 2850.00 |     4 |
			| CLARK  | 2450.00 |     4 |
			| SCOTT  | 3000.00 |     4 |
			| KING   | 5000.00 |     5 |
			| TURNER | 1500.00 |     3 |
			| ADAMS  | 1100.00 |     1 |
			| JAMES  |  950.00 |     1 |
			| FORD   | 3000.00 |     4 |
			| MILLER | 1300.00 |     2 |
			+--------+---------+-------+
			14 rows in set (0.00 sec)
	
	7.内连接-自连接
		案例：查询员工的上级领导，要求显示员工名和对应的领导名？
			// e1.mgr = e2.empno，员工的领导编号 等于 领导的员工编号
			mysql>  select e1.ename as employee,e2.ename as employer from emp e1 join emp e2 on e1.mgr = e2.empno;
			+----------+----------+
			| employee | employer |
			+----------+----------+
			| SMITH    | FORD     |
			| ALLEN    | BLAKE    |
			| WARD     | BLAKE    |
			| JONES    | KING     |
			| MARTIN   | BLAKE    |
			| BLAKE    | KING     |
			| CLARK    | KING     |
			| SCOTT    | JONES    |
			| TURNER   | BLAKE    |
			| ADAMS    | SCOTT    |
			| JAMES    | BLAKE    |
			| FORD     | JONES    |
			| MILLER   | CLARK    |
			+----------+----------+
			13 rows in set (0.00 sec)
			13条记录，没有KING
			
			以上就是内连接中的自连接，自连接的技巧就是：一张表看做两张表
	
	8.外连接
	
		mysql> select * from emp;
		+-------+--------+-----------+------+------------+---------+---------+--------+
		| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |
		+-------+--------+-----------+------+------------+---------+---------+--------+
		|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |
		|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |
		|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |
		|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |
		|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |
		|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |
		|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |
		|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |
		|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |
		|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |
		|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |
		|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |
		|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |
		|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |
		+-------+--------+-----------+------+------------+---------+---------+--------+
		14 rows in set (0.00 sec)
		
		mysql> select * from dept;
		+--------+------------+----------+
		| DEPTNO | DNAME      | LOC      |
		+--------+------------+----------+
		|     10 | ACCOUNTING | NEW YORK |
		|     20 | RESEARCH   | DALLAS   |
		|     30 | SALES      | CHICAGO  |
		|     40 | OPERATIONS | BOSTON   |
		+--------+------------+----------+
		4 rows in set (0.00 sec)
	
	内连接：(A和B连接，两张表是平等的)
	SELECT
		e.ename,
		d.dname 
	FROM
		emp e
			JOIN 
		dept d 
	ON 
		e.deptno = d.deptno;// 内连接的特点：将能够匹配上这个条件的数据查询出来
	+--------+------------+
	| ename  | dname      |
	+--------+------------+
	| SMITH  | RESEARCH   |
	| ALLEN  | SALES      |
	| WARD   | SALES      |
	| JONES  | RESEARCH   |
	| MARTIN | SALES      |
	| BLAKE  | SALES      |
	| CLARK  | ACCOUNTING |
	| SCOTT  | RESEARCH   |
	| KING   | ACCOUNTING |
	| TURNER | SALES      |
	| ADAMS  | RESEARCH   |
	| JAMES  | SALES      |
	| FORD   | RESEARCH   |
	| MILLER | ACCOUNTING |
	+--------+------------+
	14 rows in set (0.00 sec)
	
	外连接(右外连接)：outer是可以省略的，带上outer可读性强
		// emp e right join dept d，
		// right代表什么：表示将join关键字右边的这张表看做主表，
		// 主要是为了将这张表的数据全部查询出来，捎带着关联查询左边的表
		// 外连接中，两张表分主次关系
		mysql> select e.ename,d.dname from emp e right outer join dept d on e.deptno = d.deptno;
		+--------+------------+
		| ename  | dname      |
		+--------+------------+
		| MILLER | ACCOUNTING |
		| KING   | ACCOUNTING |
		| CLARK  | ACCOUNTING |
		| FORD   | RESEARCH   |
		| ADAMS  | RESEARCH   |
		| SCOTT  | RESEARCH   |
		| JONES  | RESEARCH   |
		| SMITH  | RESEARCH   |
		| JAMES  | SALES      |
		| TURNER | SALES      |
		| BLAKE  | SALES      |
		| MARTIN | SALES      |
		| WARD   | SALES      |
		| ALLEN  | SALES      |
		| NULL   | OPERATIONS |
		+--------+------------+
		15 rows in set (0.00 sec)
		
	外连接(左外连接)：
		mysql> select e.ename,d.dname from dept d left outer join emp e on e.deptno = d.deptno;
		+--------+------------+
		| ename  | dname      |
		+--------+------------+
		| MILLER | ACCOUNTING |
		| KING   | ACCOUNTING |
		| CLARK  | ACCOUNTING |
		| FORD   | RESEARCH   |
		| ADAMS  | RESEARCH   |
		| SCOTT  | RESEARCH   |
		| JONES  | RESEARCH   |
		| SMITH  | RESEARCH   |
		| JAMES  | SALES      |
		| TURNER | SALES      |
		| BLAKE  | SALES      |
		| MARTIN | SALES      |
		| WARD   | SALES      |
		| ALLEN  | SALES      |
		| NULL   | OPERATIONS |
		+--------+------------+
		15 rows in set (0.00 sec)
	
	带有right的是右外连接，又叫做右连接；
	带有left的是左外连接，又叫做左连接；
	任何一个右连接都有左连接的写法，任何一个左连接都有右连接的写法
	
	思考：外连接的查询结果条数一定是大于等于内连接的查询结果条数？
		正确。
	
	案例：查询每个员工的上级领导，要求显示所有员工的姓名和领导名？
		mysql> select empno,ename,mgr from emp;
		+-------+--------+------+
		| empno | ename  | mgr  |
		+-------+--------+------+
		|  7369 | SMITH  | 7902 |
		|  7499 | ALLEN  | 7698 |
		|  7521 | WARD   | 7698 |
		|  7566 | JONES  | 7839 |
		|  7654 | MARTIN | 7698 |
		|  7698 | BLAKE  | 7839 |
		|  7782 | CLARK  | 7839 |
		|  7788 | SCOTT  | 7566 |
		|  7839 | KING   | NULL |
		|  7844 | TURNER | 7698 |
		|  7876 | ADAMS  | 7788 |
		|  7900 | JAMES  | 7698 |
		|  7902 | FORD   | 7566 |
		|  7934 | MILLER | 7782 |
		+-------+--------+------+
		14 rows in set (0.00 sec)
	
		mysql> select e1.ename '员工',e2.ename '领导' from emp e1 left join emp e2 on e1.mgr = e2.empno;
		+--------+--------+
		| 员工   | 领导   |
		+--------+--------+
		| SMITH  | FORD   |
		| ALLEN  | BLAKE  |
		| WARD   | BLAKE  |
		| JONES  | KING   |
		| MARTIN | BLAKE  |
		| BLAKE  | KING   |
		| CLARK  | KING   |
		| SCOTT  | JONES  |
		| KING   | NULL   |
		| TURNER | BLAKE  |
		| ADAMS  | SCOTT  |
		| JAMES  | BLAKE  |
		| FORD   | JONES  |
		| MILLER | CLARK  |
		+--------+--------+
		14 rows in set (0.00 sec)
	9.多张表如何连接？
		语法：
			select
				...
			from
				a
			join
				b
			on
				a和b的连接条件
			join 
				c
			on
				a和c的连接条件
			right join 
				d
			on 
				a和d的连接条件	
		
		一条SQL中，内连接和外连接可以混合。都可以实现。
		
		案例：找出每个员工的部门名称，以及工资等级，
			要求显示员工名、部门名、薪资和薪资等级？
		
			mysql> SELECT
						e.ename,
						d.dname,
						e.sal,
						s.grade 
					FROM
						emp e
						LEFT JOIN dept d ON e.deptno = d.deptno
						LEFT JOIN salgrade s ON e.sal BETWEEN s.losal 
						AND s.hisal;
			+--------+------------+---------+-------+
			| ename  | dname      | sal     | grade |
			+--------+------------+---------+-------+
			| SMITH  | RESEARCH   |  800.00 |     1 |
			| ALLEN  | SALES      | 1600.00 |     3 |
			| WARD   | SALES      | 1250.00 |     2 |
			| JONES  | RESEARCH   | 2975.00 |     4 |
			| MARTIN | SALES      | 1250.00 |     2 |
			| BLAKE  | SALES      | 2850.00 |     4 |
			| CLARK  | ACCOUNTING | 2450.00 |     4 |
			| SCOTT  | RESEARCH   | 3000.00 |     4 |
			| KING   | ACCOUNTING | 5000.00 |     5 |
			| TURNER | SALES      | 1500.00 |     3 |
			| ADAMS  | RESEARCH   | 1100.00 |     1 |
			| JAMES  | SALES      |  950.00 |     1 |
			| FORD   | RESEARCH   | 3000.00 |     4 |
			| MILLER | ACCOUNTING | 1300.00 |     2 |
			+--------+------------+---------+-------+
			14 rows in set (0.00 sec)
		案例：找出每个员工的部门名称，以及工资等级，还有上级领导
			要求显示每个员工名、领导名，部门名、薪资和薪资等级？
			mysql> 
				SELECT
					e1.ename '员工名',
					e2.ename '领导名',
					d.dname '部门名称',
					e1.sal '薪资',
					s.grade '薪资等级' 
				FROM
					emp e1
					LEFT JOIN emp e2 ON e1.mgr = e2.empno
					LEFT JOIN dept d ON e1.deptno = d.deptno
					LEFT JOIN salgrade s ON e1.sal BETWEEN s.losal 
					AND s.hisal;
			+-----------+-----------+--------------+---------+--------------+
			| 员工名    | 领导名    | 部门名称     | 薪资    | 薪资等级     |
			+-----------+-----------+--------------+---------+--------------+
			| SMITH     | FORD      | RESEARCH     |  800.00 |            1 |
			| ALLEN     | BLAKE     | SALES        | 1600.00 |            3 |
			| WARD      | BLAKE     | SALES        | 1250.00 |            2 |
			| JONES     | KING      | RESEARCH     | 2975.00 |            4 |
			| MARTIN    | BLAKE     | SALES        | 1250.00 |            2 |
			| BLAKE     | KING      | SALES        | 2850.00 |            4 |
			| CLARK     | KING      | ACCOUNTING   | 2450.00 |            4 |
			| SCOTT     | JONES     | RESEARCH     | 3000.00 |            4 |
			| KING      | NULL      | ACCOUNTING   | 5000.00 |            5 |
			| TURNER    | BLAKE     | SALES        | 1500.00 |            3 |
			| ADAMS     | SCOTT     | RESEARCH     | 1100.00 |            1 |
			| JAMES     | BLAKE     | SALES        |  950.00 |            1 |
			| FORD      | JONES     | RESEARCH     | 3000.00 |            4 |
			| MILLER    | CLARK     | ACCOUNTING   | 1300.00 |            2 |
			+-----------+-----------+--------------+---------+--------------+
			14 rows in set (0.00 sec)
3.子查询
	1.什么是子查询？
		select语句中嵌套select语句，被嵌套的select语句称为子查询。
	2.子查询都可以出现在哪里呢？
		select
			..(select).
		from
			..(select).
		where
			..(select).
		
		案例：找出比最低工资高的员工姓名？
		实现思路：
			第一步：查询最低工资是多少？
				mysql> select min(sal) from emp;
				+----------+
				| min(sal) |
				+----------+
				|   800.00 |
				+----------+
				1 row in set (0.00 sec)
			第二步：找出大于800的
				mysql> select ename,sal from emp where sal>'800';
				+--------+---------+
				| ename  | sal     |
				+--------+---------+
				| ALLEN  | 1600.00 |
				| WARD   | 1250.00 |
				| JONES  | 2975.00 |
				| MARTIN | 1250.00 |
				| BLAKE  | 2850.00 |
				| CLARK  | 2450.00 |
				| SCOTT  | 3000.00 |
				| KING   | 5000.00 |
				| TURNER | 1500.00 |
				| ADAMS  | 1100.00 |
				| JAMES  |  950.00 |
				| FORD   | 3000.00 |
				| MILLER | 1300.00 |
				+--------+---------+
				13 rows in set (0.00 sec)
			第三步：合并前2条语句
				mysql> SELECT ename, sal FROM emp WHERE sal >( SELECT min( sal ) FROM emp );
				+--------+---------+
				| ename  | sal     |
				+--------+---------+
				| ALLEN  | 1600.00 |
				| WARD   | 1250.00 |
				| JONES  | 2975.00 |
				| MARTIN | 1250.00 |
				| BLAKE  | 2850.00 |
				| CLARK  | 2450.00 |
				| SCOTT  | 3000.00 |
				| KING   | 5000.00 |
				| TURNER | 1500.00 |
				| ADAMS  | 1100.00 |
				| JAMES  |  950.00 |
				| FORD   | 3000.00 |
				| MILLER | 1300.00 |
				+--------+---------+
				13 rows in set (0.00 sec)
				
	3.from子句中的子查询
		注意：from后面的子查询，可以将子查询的查询结果当做一张临时表。(技巧)
		
		案例：找出每个岗位的平均工资的薪资等级？
			第一步：找出每个岗位的平均工资(按照岗位分组求平均值)
				mysql> select job,avg(sal) from  emp group by job; // t表
				+-----------+-------------+
				| job       | avg(sal)    |
				+-----------+-------------+
				| CLERK     | 1037.500000 |
				| SALESMAN  | 1400.000000 |
				| MANAGER   | 2758.333333 |
				| ANALYST   | 3000.000000 |
				| PRESIDENT | 5000.000000 |
				+-----------+-------------+ 
				5 rows in set (0.00 sec)
			第二步：把以上的查询结果作为真实存在的表t
				mysql> select * from salgrade; // s表
				+-------+-------+-------+
				| GRADE | LOSAL | HISAL |
				+-------+-------+-------+
				|     1 |   700 |  1200 |
				|     2 |  1201 |  1400 |
				|     3 |  1401 |  2000 |
				|     4 |  2001 |  3000 |
				|     5 |  3001 |  9999 |
				+-------+-------+-------+ 
				5 rows in set (0.00 sec)
				
				将t表和s表进行连接，条件是：t表中的avg(sal) between s.losal and s.hisal;
					mysql>
						SELECT
							t.job,
							t.avgSal,
							s.grade 
						FROM
							( SELECT job, avg( sal ) AS avgSal FROM emp GROUP BY job ) AS t
							LEFT JOIN salgrade AS s ON t.avgSal BETWEEN s.losal 
							AND s.hisal;
					+-----------+-------------+-------+
					| job       | avgSal      | grade |
					+-----------+-------------+-------+
					| CLERK     | 1037.500000 |     1 |
					| SALESMAN  | 1400.000000 |     2 |
					| MANAGER   | 2758.333333 |     4 |
					| ANALYST   | 3000.000000 |     4 |
					| PRESIDENT | 5000.000000 |     5 |
					+-----------+-------------+-------+
					5 rows in set (0.00 sec)
	4.select后面出现的子查询(这个内容不需要掌握，了解即可)
		案例：找出每个员工的部门名称？要求显示员工名和部门名？
			mysql>
				SELECT e.ename,( SELECT d.dname FROM dept d WHERE e.deptno = d.deptno ) AS dname 
				FROM
					emp e;
				+--------+------------+
				| ename  | dname      |
				+--------+------------+
				| SMITH  | RESEARCH   |
				| ALLEN  | SALES      |
				| WARD   | SALES      |
				| JONES  | RESEARCH   |
				| MARTIN | SALES      |
				| BLAKE  | SALES      |
				| CLARK  | ACCOUNTING |
				| SCOTT  | RESEARCH   |
				| KING   | ACCOUNTING |
				| TURNER | SALES      |
				| ADAMS  | RESEARCH   |
				| JAMES  | SALES      |
				| FORD   | RESEARCH   |
				| MILLER | ACCOUNTING |
				+--------+------------+
				14 rows in set (0.00 sec)
			
			// 错误案例
			// mysql> select e.ename,(select d.dname from dept d) as dname from emp e;
			// ERROR 1242 (21000): Subquery returns more than 1 row
		
		注意：对于select后面的子查询来说，这个子查询只能一次返回1条结果
			大于1条就会报错
	
4.union合并查询结果集合
	案例：查询工作岗位是MANAGER或SALESMAN的员工？
		mysql> select * from emp where job in ('MANAGER','SALESMAN');
		+-------+--------+----------+------+------------+---------+---------+--------+
		| EMPNO | ENAME  | JOB      | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |
		+-------+--------+----------+------+------------+---------+---------+--------+
		|  7499 | ALLEN  | SALESMAN | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |
		|  7521 | WARD   | SALESMAN | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |
		|  7566 | JONES  | MANAGER  | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |
		|  7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |
		|  7698 | BLAKE  | MANAGER  | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |
		|  7782 | CLARK  | MANAGER  | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |
		|  7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |
		+-------+--------+----------+------+------------+---------+---------+--------+
		7 rows in set (0.00 sec)

		mysql> select * from emp where job = 'MANAGER' or job = 'SALESMAN';
		+-------+--------+----------+------+------------+---------+---------+--------+
		| EMPNO | ENAME  | JOB      | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |
		+-------+--------+----------+------+------------+---------+---------+--------+
		|  7499 | ALLEN  | SALESMAN | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |
		|  7521 | WARD   | SALESMAN | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |
		|  7566 | JONES  | MANAGER  | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |
		|  7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |
		|  7698 | BLAKE  | MANAGER  | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |
		|  7782 | CLARK  | MANAGER  | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |
		|  7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |
		+-------+--------+----------+------+------------+---------+---------+--------+
		7 rows in set (0.00 sec)	
		
	使用union进行合并结果查询
		mysql> select * from emp where job='MANAGER' union select * from emp where job = 'SALESMAN';
		+-------+--------+----------+------+------------+---------+---------+--------+
		| EMPNO | ENAME  | JOB      | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |
		+-------+--------+----------+------+------------+---------+---------+--------+
		|  7566 | JONES  | MANAGER  | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |
		|  7698 | BLAKE  | MANAGER  | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |
		|  7782 | CLARK  | MANAGER  | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |
		|  7499 | ALLEN  | SALESMAN | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |
		|  7521 | WARD   | SALESMAN | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |
		|  7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |
		|  7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |
		+-------+--------+----------+------+------------+---------+---------+--------+
		7 rows in set (0.01 sec)
	
	union的效率要高一些。对于表连接来说，每连接一次新表，
	则匹配的次数满足笛卡尔积，成倍增加匹配次数。
	但是union可以减少匹配次数，在减少匹配次数的情况下，
	还可以完成两个结果集的拼接。
	
	a连接b连接c
	a 10条记录
	b 10条记录
	c 10条记录	
	匹配次数是：10 * 10 * 10 -> 1000次
	
	a连接b的一个结果是：10 * 10 -> 100次
	a连接c的一个结果是：10 * 10 -> 100次
	使用union的话是：100 + 100 -> 200次(把乘法变成加法运算)
	
	union在使用的时候的注意事项？
		// 错误的：union在进行结果拼接的时候，要求两个结果集的列数相同
		mysql> select ename,job from emp where job='MANAGER' union select ename from emp where job = 'SALESMAN';
		ERROR 1222 (21000): The used SELECT statements have a different number of columns
		// MySQL可以，Oracle语法严格，不可以。报错
		// 要求结果集合并时列和列的数据类型也要是一样
		mysql> select ename,job from emp where job='MANAGER' union select ename from emp,sal where job = 'SALESMAN';
		ERROR 1146 (42S02): Table 'bjpowernode.sal' doesn't exist
		
		结论：合并的两个结果集的列数相同、数据类型相同

5.limit(非常重要)
	1.limit是将查询结果集的一部分取出来，通常使用在分页查询当中
		百度默认：一页显示10条搜索记录
		分页的作用：为了提高用户体验，因为一次全部查出来，用户体验差
		可以一页一页的翻。
	
	2.limit怎么使用？
		完整用法：limit startIndex,length
			startIndex是起始下标，length是截取长度
			起始下标从0开始
			
		案例：按照薪资降序，取出排名在前五的员工信息？
			mysql> select ename,sal from emp order by sal desc limit 5;
			或
			mysql> select ename,sal from emp order by sal desc limit 0,5;
			+-------+---------+
			| ename | sal     |
			+-------+---------+
			| KING  | 5000.00 |
			| SCOTT | 3000.00 |
			| FORD  | 3000.00 |
			| JONES | 2975.00 |
			| BLAKE | 2850.00 |
			+-------+---------+
			5 rows in set (0.00 sec)
	
	3.注意：MySQL当中，limit是在order by之后执行。
		案例：取工资排名在3-5名的员工？
			
			//limit 2,3 
			// 其中，2表示起始位置从2下标开始，就是第三条记录
			// 3表示截取的长度 3-5名员工，共有3个
			
			mysql> select ename,sal from emp order by sal desc limit 2,3;
			+-------+---------+
			| ename | sal     |
			+-------+---------+
			| FORD  | 3000.00 |
			| JONES | 2975.00 |
			| BLAKE | 2850.00 |
			+-------+---------+
			3 rows in set (0.00 sec)
		
		案例：取出工资排名在[5,9]名的员工？
			mysql> select ename,sal from emp order by sal desc limit 4,5;
			+--------+---------+
			| ename  | sal     |
			+--------+---------+
			| BLAKE  | 2850.00 |
			| CLARK  | 2450.00 |
			| ALLEN  | 1600.00 |
			| TURNER | 1500.00 |
			| MILLER | 1300.00 |
			+--------+---------+
			5 rows in set (0.00 sec)
		
		案例：分页
			每页显示3条记录
			第1页 limit 0,3;	[0 1 2]
			第2页 limit 3,3;	[3 4 5]
			第3页 limit 6,3;	[6 7 8]
			第4页 limit 9,3;	[9 10 11]
			
			每页显示pageSize条记录
			第pageNo页：limit (pageNo - 1) * pageSize, pageSize;
			
			public static void main(String[] void){
				int  pageNo = 5; // 页码
				int pageSize = 10; // 每页显示pageSize条记录
				
				// 计算开始索引位置
				int startIndex = (pageNo - 1) * pageSize;
				// 拼接SQL语句
				String sql = "select xxx from xxx order by xxx" + startIndex + "," + pageSize;
			}
			
			公式：limit (pageNo - 1) * pageSize, pageSize;
	
	4.关于DQL语句的大总结
		select 
			...
		from
			...
		group by
			...
		having 
			...
		order by
			...
		limit
			...
		
		执行顺序？
			1.from
			2.where
			3.group by
			4.having 
			5.select
			6.order by
			7.limit

6.表的创建(建表)
	1.建表的语法格式：(建表属于DDL语句，DDL包括：create drop alter)
		create table 表名(字段名1 数据类型,字段名2 数据类型,字段名3 数据类型,...);
		create table 表名(
			字段名1 数据类型,
			字段名2 数据类型,
			字段名3 数据类型
		);
		
		表名：建议以t_或者tbl_开始，可读性强，见名知意
		字段名：见名知意
		表名和字段名都属于标识符
		
	2.关于MySQL中的数据类型
		很多数据类型，我们只需要掌握一些常见的数据类型即可。
			varchar
				可变长度的字符串(variable char)
				最长255个字符长度
				比较智能，节省空间
				会根据实际的数据长度动态分配空间
				
				优点：节省空间
				缺点：需要动态分配空间，速度慢，效率低
			
			char
				定长的字符串
				最长255个字符长度
				不管实际的数据长度是多少，分配固定长度的空间去存储数据
				使用不恰当的时候，可能会导致空间的浪费
				
				优点：不需要动态分配空间，速度快，效率高
				缺点：使用不当可能会导致空间的浪费
				
				varchar和char应该如何选择？
					性别字段：char。因为性别是固定长度的字符串，所以选择char
					姓名字段：varchar。每个人的名字长度不一样，所以选择varchar
			
			int
				最长11位
				数字中的整数型，等同于java中的int。
			
			bigint
				数字中的整数型，等同于java中的long。
			
			float
				单精度浮点型数据
			
			double
				双精度浮点型数据
			
			data
				短日期类型
				
			datatime
				长日期类型
			
			clob
				字符大对象
				最多可以存储4G的字符串
				比如：存储一篇文章，存储一个说明
				超过255个字符的，都要采用字符大对象来存储
				Character Large OBject:CLOB
			
			blob
				二进制大对象
				专门用来存储图片、声音、视频等流媒体数据
				往BLOB类型的字段值插入数据的时候，例如插入一张图片、一个视频等
				需要使用IO流才行
				Binary Large OBject:BLOB
		
		案例：创建一个电影表
			t_movie  电影表 (专门用来存储电影信息的表)
				no(bigint):电影编号,10000,10001
				name(varchar):电影名字,'哪吒','林正英之娘娘'
				history(clob):故事情节,'',''
				playtime(data):上映日期,2019-10-11,2019-11-11
				time(double):时长,2.5,1.5
				image(blob):电影宣传海报,
				type(char):类型,'1','2'
	
	3.创建学生表
		学号、姓名、年龄、性别、邮箱地址
		create table t_student(
			no int,
			name varchar(32),
			sex char(1),
			age int(3),
			email varchar(255)
		);
		
		删除表：
			drop table t_student; // 当这张表不存在的时候会报错
			// 如果这张表存在的话，删除
			drop table if exists t_student;
	4.插入数据insert(DML语句)
		语法格式：
			insert into 表名(字段名1 数据类型,字段名2 数据类型,字段名3 数据类型,...) values(值1，值2，值3);
			注意：字段名和值要一一对应，数量要对应，数据类型要对应。
		
		insert into t_student(no,name,sex,age,email) values(1,'zhangsan','m',20,'zhangsan01@123.com');
		insert into t_student(email,name,sex,age,no) values('lisi@123.com','lisi','f',20,2);
		
		mysql> insert into t_student(no) values(3);
		Query OK, 1 row affected (0.00 sec)

		mysql> select * from t_student;
		+------+----------+------+------+--------------------+
		| no   | name     | sex  | age  | email              |
		+------+----------+------+------+--------------------+
		|    1 | zhangsan | m    |   20 | zhangsan01@123.com |
		|    2 | lisi     | f    |   20 | lisi@123.com       |
		|    3 | NULL     | NULL | NULL | NULL               |
		+------+----------+------+------+--------------------+
		3 rows in set (0.00 sec)
		
		mysql> insert into t_student(name) values('wangwu');
		Query OK, 1 row affected (0.00 sec)

		mysql> select * from t_student;
		+------+----------+------+------+--------------------+
		| no   | name     | sex  | age  | email              |
		+------+----------+------+------+--------------------+
		|    1 | zhangsan | m    |   20 | zhangsan01@123.com |
		|    2 | lisi     | f    |   20 | lisi@123.com       |
		|    3 | NULL     | NULL | NULL | NULL               |
		| NULL | wangwu   | NULL | NULL | NULL               |
		+------+----------+------+------+--------------------+
		4 rows in set (0.00 sec)
			
		注意：inert语句但凡是执行成功了，那么必然会多一条记录。
		没有给其他字段指定值的话，默认值为null。
		
		drop table if exists t_student;
		create table t_student(
			no int,
			name varchar(32),
			sex char(1) default 'm', // 指定默认值
			age int(3),
			email varchar(255)
		);
		
		mysql> desc t_student;
		+-------+--------------+------+-----+---------+-------+
		| Field | Type         | Null | Key | Default | Extra |
		+-------+--------------+------+-----+---------+-------+
		| no    | int          | YES  |     | NULL    |       |
		| name  | varchar(32)  | YES  |     | NULL    |       |
		| sex   | char(1)      | YES  |     | m       |       |默认值
		| age   | int          | YES  |     | NULL    |       |
		| email | varchar(255) | YES  |     | NULL    |       |
		+-------+--------------+------+-----+---------+-------+
		5 rows in set (0.00 sec)
		
		mysql> insert into t_student(no) values(1);
		Query OK, 1 row affected (0.01 sec)
		mysql> select * from t_student;
		+------+------+------+------+-------+
		| no   | name | sex  | age  | email |
		+------+------+------+------+-------+
		|    1 | NULL | m    | NULL | NULL  |
		+------+------+------+------+-------+
		1 row in set (0.00 sec)
		
		insert语句中的"字段名"可以省略吗？可以
			insert into t_student values(2); // 错误的
			// 注意：前面的字段名省略的话，等于都写上了。所以值也要按照字段顺序都写上
			insert into t_student values(2,'lisi','f',20,'lisi@123.com');
			
			mysql> insert into t_student values(2,'lisi','f',20,'lisi@123.com');
			Query OK, 1 row affected (0.00 sec)

			mysql> select * from t_student;
			+------+------+------+------+--------------+
			| no   | name | sex  | age  | email        |
			+------+------+------+------+--------------+
			|    1 | NULL | m    | NULL | NULL         |
			|    2 | lisi | f    |   20 | lisi@123.com |
			+------+------+------+------+--------------+
			2 rows in set (0.00 sec)
	
	5.insert插入日期
		数字格式化：format
		mysql> select ename,sal from emp;
		+--------+---------+
		| ename  | sal     |
		+--------+---------+
		| SMITH  |  800.00 |
		| ALLEN  | 1600.00 |
		| WARD   | 1250.00 |
		| JONES  | 2975.00 |
		| MARTIN | 1250.00 |
		| BLAKE  | 2850.00 |
		| CLARK  | 2450.00 |
		| SCOTT  | 3000.00 |
		| KING   | 5000.00 |
		| TURNER | 1500.00 |
		| ADAMS  | 1100.00 |
		| JAMES  |  950.00 |
		| FORD   | 3000.00 |
		| MILLER | 1300.00 |
		+--------+---------+
		14 rows in set (0.00 sec)
		
		格式化数字：format(数字，'格式') 加入千分位
		mysql> select ename,format(sal,'$999,999') as sal from emp;
		+--------+-------+
		| ename  | sal   |
		+--------+-------+
		| SMITH  | 800   |
		| ALLEN  | 1,600 |
		| WARD   | 1,250 |
		| JONES  | 2,975 |
		| MARTIN | 1,250 |
		| BLAKE  | 2,850 |
		| CLARK  | 2,450 |
		| SCOTT  | 3,000 |
		| KING   | 5,000 |
		| TURNER | 1,500 |
		| ADAMS  | 1,100 |
		| JAMES  | 950   |
		| FORD   | 3,000 |
		| MILLER | 1,300 |
		+--------+-------+
		14 rows in set, 14 warnings (0.00 sec)
		
	str_to_date:将字符串varchar类型转换成date类型
	date_format：将data类型转换为具有一定格式的varchar字符串类型
	
	drop table if exists t_user;
	create table t_user(
		id int,
		name varchar(32),
		birth date
	);
	
	create table t_user(
	id int,
	name varchar(32),
	birth varchar(10)
	);
	
	注意：数据库中的一条命名规范：	
		所有的标识符都是全部小写，单词和单词之间使用下划线进行衔接
	
	mysql> drop table if exists t_user;
	Query OK, 0 rows affected, 1 warning (0.01 sec)

	mysql> create table t_user(
		-> id int,
		-> name varchar(32),
		-> birth date
		-> );
	Query OK, 0 rows affected (0.02 sec)

	mysql> select * from t_user;
	Empty set (0.00 sec)

	mysql> desc t_user;
	+-------+-------------+------+-----+---------+-------+
	| Field | Type        | Null | Key | Default | Extra |
	+-------+-------------+------+-----+---------+-------+
	| id    | int         | YES  |     | NULL    |       |
	| name  | varchar(32) | YES  |     | NULL    |       |
	| birth | date        | YES  |     | NULL    |       |
	+-------+-------------+------+-----+---------+-------+
	3 rows in set (0.00 sec)
	
	插入数据？
		// 错误的，类型不匹配
		// birth数据类型是date
		// 插入的数据'01-10-1990' 是varchar类型
		insert into t_user(id,name,birth) values(1,'zhangsan','01-10-1990'); // 1990年10月1日
		
		怎么办？可以实验str_to_date函数可以将字符串转换成日期类型date？
		语法格式：
			str_to_date('字符串日期','日期格式')
		
		MySQL的日期格式：
			%Y 年
			%m 月
			%d 日
			%h 时
			%i 分
			%s 秒
		
		insert into t_user(id,name,birth) values(1,'zhangsan',str_to_date('01-10-1990','%d-%m-%Y'));
		
		mysql> insert into t_user(id,name,birth) values(1,'zhangsan',str_to_date('01-10-1990','%d-%m-%Y'));
		Query OK, 1 row affected (0.01 sec)

		mysql> select * from t_user;
		+------+----------+------------+
		| id   | name     | birth      |
		+------+----------+------------+
		|    1 | zhangsan | 1990-10-01 |
		+------+----------+------------+
		1 row in set (0.00 sec)
		
		str_to_date函数可以把字符串varchar转换成日期date类型，
		通常使用在插入insert方面，因为插入的时候需要一个日期类型的数据，
		需要通过该函数将字符串转换成date
		
		如果提供的日期字符串是这个格式，str_to_date函数就不需要了，就被自动转换成对应的date格式了
			%Y-%m-%d
		insert into t_user(id,name,birth) values(2,'lisi','1990-10-01');
		
		mysql> insert into t_user(id,name,birth) values(2,'lisi','1990-10-01');
		Query OK, 1 row affected (0.01 sec)

		mysql> select * from t_user;
		+------+----------+------------+
		| id   | name     | birth      |
		+------+----------+------------+
		|    1 | zhangsan | 1990-10-01 |
		|    2 | lisi     | 1990-10-01 |
		+------+----------+------------+
		2 rows in set (0.00 sec)
		
	查询的时候，可以以某个特定的日期格式展示吗？
		date_format：这个函数可以将日期类型的数据转换成特定格式的字符串。
		
		mysql> select * from t_user;
		+------+----------+------------+
		| id   | name     | birth      |
		+------+----------+------------+
		|    1 | zhangsan | 1990-10-01 |
		|    2 | lisi     | 1990-10-01 |
		+------+----------+------------+
		2 rows in set (0.00 sec)

		mysql> select id,name,date_format(birth,'%m/%d/%Y') birth  from t_user;
		+------+----------+------------+
		| id   | name     | birth      |
		+------+----------+------------+
		|    1 | zhangsan | 10/01/1990 |
		|    2 | lisi     | 10/01/1990 |
		+------+----------+------------+
		2 rows in set (0.00 sec)
	
		date_format函数怎么用？
			date_format(日期类型数据,'日期格式')
			这个函数通常使用在查询日期方面， 设置展示的日期格式
			
			mysql> select * from t_user;
			+------+----------+------------+
			| id   | name     | birth      |
			+------+----------+------------+
			|    1 | zhangsan | 1990-10-01 |
			|    2 | lisi     | 1990-10-01 |
			+------+----------+------------+
			2 rows in set (0.00 sec)
			
			以上的SQL语句实际上式进行了默认的日期格式，
			自动将数据库中的date类型数据转换成varchar
			并且采用的格式是MySQL默认的日期格式：'%Y-%m-%d'
			
			java中的数据格式？
				yyyy-MM-dd HH:mm:ss SSS
	
	6.date和datetime两个类型的区别？
		date是短日期：只包括年月日信息
		datetime是长日期：包括年月日时分秒信息
		
		drop table if exists t_user;
		create table t_user(
			id int,
			name varchar(32),
			birth date,
			create_time datetime
		);
		
		id是整数
		name是字符串
		birth是短日期
		create_time是这条记录的创建时间：长日期类型
		
		MySQL短日期的默认格式：%Y-%m-%d
		MySQL长日期的默认格式：%Y-%m-%d %h:%i:%s
		
		插入数据：
			insert into t_user(id,name,birth,create_time) values(1,'zhangsan','1990-10-01','2020-03-18 15:49:50');
		
		mysql> drop table if exists t_user;
		Query OK, 0 rows affected, 1 warning (0.01 sec)

		mysql> create table t_user(
			-> id int,
			-> name varchar(32),
			-> birth date,
			-> create_time datetime
			-> );
		Query OK, 0 rows affected (0.04 sec)

		mysql> insert into t_user(id,name,birth,create_time) values(1,'zhangsan','1990-10-01','2020-03-18 15:49:50');
		Query OK, 1 row affected (0.01 sec)

		mysql> select * from t_user;
		+------+----------+------------+---------------------+
		| id   | name     | birth      | create_time         |
		+------+----------+------------+---------------------+
		|    1 | zhangsan | 1990-10-01 | 2020-03-18 15:49:50 |
		+------+----------+------------+---------------------+
		1 row in set (0.00 sec)	
		
		一次可以插入多条记录？
		语法格式：insert into t_user(id,name,birth,create_time) values(),(),(),()...;
		mysql> 
		insert into t_user(id,name,birth,create_time) values(1,'zhangsan','1980-10-01',now()),
			(2,'lisi','1982-08-01',now()),
			(3,'wangwu','1980-02-01',now())
			;
		Query OK, 3 rows affected (0.02 sec)
		Records: 3  Duplicates: 0  Warnings: 0

		mysql> select * from t_user;
		+------+----------+------------+---------------------+
		| id   | name     | birth      | create_time         |
		+------+----------+------------+---------------------+
		|    1 | zhangsan | 1980-10-01 | 2021-05-11 15:29:01 |
		|    2 | lisi     | 1982-08-01 | 2021-05-11 15:29:01 |
		|    3 | wangwu   | 1980-02-01 | 2021-05-11 15:29:01 |
		+------+----------+------------+---------------------+
		3 rows in set (0.00 sec)
			
		在MySQL中如何获取系统的当前时间？
			now() 函数，并且获取的时间带有时分秒信息。是datetime类型的数据
			insert into t_user(id,name,birth,create_time) values(2,'lisi','1990-11-11',now());
			
			mysql> insert into t_user(id,name,birth,create_time) values(2,'lisi','1990-11-11',now());
			Query OK, 1 row affected (0.01 sec)

			mysql> select * from t_user;
			+------+----------+------------+---------------------+
			| id   | name     | birth      | create_time         |
			+------+----------+------------+---------------------+
			|    1 | zhangsan | 1990-10-01 | 2020-03-18 15:49:50 |
			|    2 | lisi     | 1990-11-11 | 2021-05-11 13:26:11 |
			+------+----------+------------+---------------------+
			2 rows in set (0.00 sec)
	
	7.修改(update) (DML语句)
		语法格式：
			update 表名 set 字段名1=值1，字段名2=值2，字段名3=值3... hwere 条件;
			注意：没有条件限制，会导致所有数据的更新
			
			// 修改id为2的那一行数据的name 和 birth
			mysql> update t_user set name='Jack',birth = '2000-10-01' where id='2';
			Query OK, 1 row affected (0.01 sec)
			Rows matched: 1  Changed: 1  Warnings: 0

			mysql> select * from t_user;
			+------+----------+------------+---------------------+
			| id   | name     | birth      | create_time         |
			+------+----------+------------+---------------------+
			|    1 | zhangsan | 1990-10-01 | 2020-03-18 15:49:50 |
			|    2 | Jack     | 2000-10-01 | 2021-05-11 13:26:11 |
			+------+----------+------------+---------------------+
			2 rows in set (0.00 sec)
			
			// 修改id为2的那一行数据的name、birth，将create_time改为当前时间now()
			mysql> update t_user set name='Jack',birth = '2000-10-01',create_time = now() where id = '2';
			Query OK, 1 row affected (0.01 sec)
			Rows matched: 1  Changed: 1  Warnings: 0

			mysql> select * from t_user;
			+------+----------+------------+---------------------+
			| id   | name     | birth      | create_time         |
			+------+----------+------------+---------------------+
			|    1 | zhangsan | 1990-10-01 | 2020-03-18 15:49:50 |
			|    2 | Jack     | 2000-10-01 | 2021-05-11 13:33:54 |
			+------+----------+------------+---------------------+
			2 rows in set (0.00 sec)
			
			// 不加where限制条件，则更新所有
			mysql> update t_user set name = 'abc';
			Query OK, 2 rows affected (0.02 sec)
			Rows matched: 2  Changed: 2  Warnings: 0

			mysql> select * from t_user;
			+------+------+------------+---------------------+
			| id   | name | birth      | create_time         |
			+------+------+------------+---------------------+
			|    1 | abc  | 1990-10-01 | 2020-03-18 15:49:50 |
			|    2 | abc  | 2000-10-01 | 2021-05-11 13:33:54 |
			+------+------+------------+---------------------+
			2 rows in set (0.00 sec)
	8.删除数据 delete(DML语句)
		语法格式：delete from 表名 where 条件;
		注意：没有条件，整张表的数据都会被删除
		
		// 删除t_user表中id=2的数据
		mysql> delete from t_user where id='2';
		Query OK, 1 row affected (0.01 sec)

		mysql> select * from t_user;
		+------+------+------------+---------------------+
		| id   | name | birth      | create_time         |
		+------+------+------------+---------------------+
		|    1 | abc  | 1990-10-01 | 2020-03-18 15:49:50 |
		+------+------+------------+---------------------+
		1 row in set (0.00 sec)
		
		// 不加where限制条件，清空整张表格
		mysql> insert into t_user(id) values(2);
		Query OK, 1 row affected (0.01 sec)

		mysql> select * from t_user;
		+------+------+------------+---------------------+
		| id   | name | birth      | create_time         |
		+------+------+------------+---------------------+
		|    1 | abc  | 1990-10-01 | 2020-03-18 15:49:50 |
		|    2 | NULL | NULL       | NULL                |
		+------+------+------------+---------------------+
		2 rows in set (0.00 sec)

		mysql> delete from t_user;
		Query OK, 2 rows affected (0.01 sec)

		mysql> select * from t_user;
		Empty set (0.00 sec)
		
		增删改查：insert delete update select
			insert语法格式：
			insert into 表名(字段名1 数据类型,字段名2 数据类型,字段名3 数据类型,...) values(值1，值2，值3);
			
			delete语法格式：
			delete from 表名 where 条件;
			
			update语法格式：
			update 表名 set 字段名1=值1，字段名2=值2，字段名3=值3... where 条件;
		
	
			
		